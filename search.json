[
  {
    "objectID": "02_project-structure.html",
    "href": "02_project-structure.html",
    "title": "2. Project Structure",
    "section": "",
    "text": "If you get hit by a bus today, will your colleagues be able to run your project tomorrow?\nThe Bus Factor\nSoftware projects can be messy. Imagine you join a lab and your supervisor hands a project folder left by a previous postdoc. It usually looks like this:\nOK, probably not as extreme. Still, it is common for a newcomer to data science to put everything into a single folder: data, scripts, figures, tables. That can work if you only need to do analysis once and no one else will ever do it again, including yourself. That is far from truth in research be it academia or industry. In this tutorial we will see quick fixes you can do to help others and the future you to understand what does a project do. Let’s get organized.",
    "crumbs": [
      "2. Project Structure"
    ]
  },
  {
    "objectID": "02_project-structure.html#messy-project",
    "href": "02_project-structure.html#messy-project",
    "title": "2. Project Structure",
    "section": "Messy Project",
    "text": "Messy Project\n.\n├── analysis.sh\n├── book1.txt\n├── book102.txt\n├── book2.txt\n├── book3.txt\n├── book5.txt\n├── book55.txt\n├── book79.txt\n├── plot.sh\n└── summary.sh\nFirst, try to make sense what the project is about and how to use it.\nDOWNLOAD HERE\nIf you want to practice your terminal skills, you can unzip the file with unzip program:\nunzip gecs-02-project_structure-2025-02_messy-dir\nOnce unzipped, open the directory with VS Code (Cmd+O).",
    "crumbs": [
      "2. Project Structure"
    ]
  },
  {
    "objectID": "02_project-structure.html#structured-project",
    "href": "02_project-structure.html#structured-project",
    "title": "2. Project Structure",
    "section": "Structured Project",
    "text": "Structured Project\n.\n├── books                           &lt;-- Text files of books used for analysis\n│   ├── dracula.txt\n│   ├── frankenstein.txt\n│   ├── jane_eyre.txt\n│   ├── moby_dick.txt\n│   ├── README.md                   &lt;-- README for the book files\n│   ├── sense_and_sensibility.txt\n│   ├── sherlock_holmes.txt\n│   └── time_machine.txt\n├── counts                          &lt;-- Word count .tsv data\n├── figures                         &lt;-- Bar plots of word counts\n├── README.md                       &lt;-- README for the project\n└── scripts                         &lt;-- Scripts directory\n    ├── count_words.sh              &lt;-- Counts occurences of word in a books\n    ├── get_summary.sh              &lt;-- Gets a book summary\n    └── plot_counts.sh              &lt;-- Plots count histogram in terminal window\nThis is the same project but organized.\nDOWNLOAD HERE\nOnce downloaded and unzipped, open the directory with VS Code.",
    "crumbs": [
      "2. Project Structure"
    ]
  },
  {
    "objectID": "02_project-structure.html#directory-structure",
    "href": "02_project-structure.html#directory-structure",
    "title": "2. Project Structure",
    "section": "Directory Structure",
    "text": "Directory Structure\nHere is a minimal directory structure adapted from bvreede on GitHub. There are larger.\nThe directory structure distinguishes three kinds of folders:\n\nRead-only (RO): not edited by either code or researcher\nHuman-writeable (HW): edited by the researcher only.\nProject-generated (PG): folders generated when running the code; these folders can be deleted or emptied and will be completely reconstituted as the project is run.\n\n.\n├── README.md          &lt;- Description and how to run the project (HW)\n├── requirements.txt   &lt;- System requirements for running the project (HW)\n├── processed_data     &lt;- Processed data ready for analysis (PG)\n├── raw_data           &lt;- The original, immutable data dump (RO)\n├── scripts            &lt;- Scripts for this project (HW)\n└── results            &lt;- Project results: tables, figures, etc. (PG)",
    "crumbs": [
      "2. Project Structure"
    ]
  },
  {
    "objectID": "02_project-structure.html#naming-files-and-directories",
    "href": "02_project-structure.html#naming-files-and-directories",
    "title": "2. Project Structure",
    "section": "Naming Files and Directories",
    "text": "Naming Files and Directories\nJenny Bryan from The Carpentiries has shared an online slides to show how to and how to not name files and directories. The presentation can be summarized as follows.\n\nKISS (Keep It Simple Stupid): use simple and consistent file names\n\nMachine readable\nHuman readable\nOrders well in a directory\n\nNo special characters and no spaces!\nUse YYYY-MM-DD date format\nUse - to delimit words and _ to delimit sections\n\ni.e. 2019-01-19_my-data.csv\n\nLeft-pad numbers\n\ni.e. 01_my-data.csv vs 1_my-data.csv\nIf you don’t, file orders get messed up when you get to double-digits\n\n\nYou can use a variation of the above as long as you are consistent within a project.",
    "crumbs": [
      "2. Project Structure"
    ]
  },
  {
    "objectID": "02_project-structure.html#readme",
    "href": "02_project-structure.html#readme",
    "title": "2. Project Structure",
    "section": "README",
    "text": "README\nREADME, or README.md since Markdown language is the standard now, is the most important file in your project. It grants the power to the new users to execute your project and, remember, your future self. Without it, almost no one will get through your project without a considerable struggle (again, including future you).\nMake a README does a great job in conveying this message in a single webpage. Check it out!",
    "crumbs": [
      "2. Project Structure"
    ]
  },
  {
    "objectID": "02_project-structure.html#project-template",
    "href": "02_project-structure.html#project-template",
    "title": "2. Project Structure",
    "section": "Project Template",
    "text": "Project Template\nInstead of creating project directory with all its supplementary files, software developers came up with a boilerplate structure that can be created in minutes. Cookie Cutter Data Science project is one of those. Although, the default template is aimed towards machine learning / data science researchers, you can find a simpler one shared by other researchers online. Another option, to create your own template that suits your needs.\n\nAlso, check out their Opinions page for project management tips.",
    "crumbs": [
      "2. Project Structure"
    ]
  },
  {
    "objectID": "00_vs-code.html",
    "href": "00_vs-code.html",
    "title": "VS Code",
    "section": "",
    "text": "In this tutorial you will get familiar with the functionality of VS Code. A powerful IDE as it is, VS Code has a lot of features. However, even if you know the basics it will get you a long way. This tutorial is heavily based on the official Tutorial: Get started with Visual Studio Code.\n\nStart Up\n\nOpen Visual Studio Code. Then open a folder with File &gt; Open Folder… or Cmd+O. On Linux/WSL users, you will first have to start a remote WSL session. With the WSL extension installed, you will see a new Status bar item at the far left.\n\nThe Remote Status bar item can quickly show you in which context VS Code is running (local or remote) and clicking on the item will bring up the WSL extension commands.\n\n\n\n\n\n\n\nAlternatively, WSL users can open their Linux terminal, create a directory in their Linux distribution file system, change their directory and open it in VS Code WSL remote with code .:\ncd\nmkdir vscode101\ncd vscode101\ncode .\nNote the . in front of code. You need to tell VS Code what you are opening. Later, we will see that you can open any file or directory with this command.\n\n\n\nSelect New Folder and create a new folder named vscode101. Then select Select Folder (Open on macOS) to open the folder in VS Code.\nOn the Workspace Trust dialog, select Yes, I trust the authors to enable all features in the workspace. If you do not see this dialog, then you probably have already opened this area before.\n\n\n\n\n\n\nWorkspace Trust lets you decide whether code in your project folder can be executed by VS Code. When you download code from the internet, you should first review it to make sure it’s safe to run. Get more info about Workspace Trust.\n\n\n\n\n\n\nYou should now see the Explorer view on the left, showing the name of the folder. Alongside terminal commands like ls, tree, and other commands, you can use the Explorer view to view and manage the files and folders in your workspace.\n\n\n\n\n\n\n\nWhen you open a folder in VS Code, VS Code can restore the UI state for that folder, such as the open files, the active view, and the layout of the editor. You can also configure settings that only apply to that folder, or define debug configurations. Get more info about workspaces.\n\n\n\n\nVS Code now considers the folder you’ve opened a workspace. You can also use code . in your terminal, especially for WSL users, to start a WSL remote session.\n\n\nInterface and Layout\n\nSidebar\nCode editor\nTerminal\n\n\n\nSettings\n\nAutosave\nWord wrap\nTheme customization\nGECS profile configuration\n\n\n\nSearching and Replacing\n\nSearch in a file\nSearch across files\n\n\n\nShortcuts\n\nLayout: Cmd+B for the Sidebar, Ctrl+` for the Terminal\nCode editor: Cmd+D for selecting the expression, Opt+Up/Down to move a line, Opt+Shift+F to format a document\nGeneral: Cmd+Shift+P for the Command Palette, Cmd+P for the File and Open Editors search bar\n\n\n\nReferences\n\nhttps://code.visualstudio.com/docs/getstarted/getting-started\nhttps://code.visualstudio.com/docs/remote/wsl-tutorial",
    "crumbs": [
      "VS Code"
    ]
  },
  {
    "objectID": "00_setting-up.html",
    "href": "00_setting-up.html",
    "title": "0. Setting Up",
    "section": "",
    "text": "This section will equip your computer with all necessary tools for this course. The motivation behind each tool will be explained in the later sessions. For now, just follow the instructions and prepare to awe (and, at times, get frustrated) with power of computing.\nAlthough the course advertises itself as programming language agnostic, Python will be used to provide ‘meat’ for coding examples. See a Justin Bois’s note on “superiority” of one programming language over another below.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting-up.html#wsl-windows-users-only",
    "href": "00_setting-up.html#wsl-windows-users-only",
    "title": "0. Setting Up",
    "section": "WSL (Windows users only)",
    "text": "WSL (Windows users only)\nBeing a popular operating system doesn’t make Windows easy to use for software development. Windows Subsystem for Linux (WSL) circumvents this problem by creating a separate environment on your computer to run Linux, a free UNIX-like OS. We will install Linux with a particular flavour called Ubuntu. Right now, we will not go into details. All you need to know is that by the end of this installation you will be free to use a vast majority of scientific software available on the web.\n\nInstallation\nThere are two ways to install WSL with Ubuntu: graphical and terminal. The graphical method uses the Microsoft Store and should be straightforward. The terminal method uses PowerShell and is less user-friendly but more robust to errors. Choose whichever suits you best.\n\n\n\n\n\n\nNoteTroubleshooting WSL\n\n\n\n\n\nIf you’re experiencing some troubles with installation, it is worth:\n\nUpdating your Windows version. Open Windows Settings, go to ‘Updates and Security’ and hit ‘Check for Updates’.\nEnable WSL on your Windows manually.\n\nClick on the Start Menu and search for “Turn Windows features on or off”.\nOpen the result. A new window will appear with a list of Windows features.\nScroll down and check the following two boxes:\n\n‘Windows Subsystem for Linux’ ✅\n‘Virtual Machine Platform’ ✅\n\nClick OK. Windows will apply the changes and may ask you to restart your computer.\nAfter restarting, WSL will be enabled on your system.\n\n\n\n\n\n\nOpen the Start Menu, and search for “PowerShell”.\nRight-click and choose “Run as administrator”.\nEnter the following command to install WSL and hit Enter:\nwsl --install\n\n\n\n\n\n\n\n\nYou need to restart your computer after installing WSL.\n\n\n\n\nOnce restarted, open PowerShell again in the administartive mode and type:\nwsl --install\nBy default, Ubuntu will be installed as the main Linux distribution.\n\n\n\nCreating a Default UNIX User Account\nNow, that you have Ubuntu installed, you need to create an account in order to start using it. Generally it is called a “UNIX User Account” but a “Ubuntu account” would do as well.\n\n\n\n\n\n\nBefore you set a username on your computer, sign up for a GitHub account (see Section 4.1) and check if that username is available. This unity in names will make it easier for you to orient your files and folder,as well establish a virtual nickname that you can use consistently in the future projects.\n\n\n\n\n\n\n\n\n\n\nTipUsername and password suggestions\n\n\n\n\n\nFor a username: - Use only lower-case letters and numbers. - Start with a letter. - Be short and descriptive.\nIf your name is John Derek Smith you can try: jsmith, jdsmith, or johnsmith. Any other imaginary name is permissible as long as it meets the criteria above. D&D, MTG, LoL, and WoW nicknames, if that’s is publically appropriate.\nFor a password, you can set the same one you have for your OIST account to make it easier to remember. It will be used for login and authentication but, more importantly, commands like sudo that grant administrative priviledges. If not sure what makes a strong password consult XKCD.\n\n\n\n\nLaunch Ubuntu terminal.\n\n\n\nYou will be prompted to enter a username.\n\n\nEnter your chosen username and hit Enter. If you make a mistake in typing your username, you can close the window and open it again. In this example, tunkert is the username.\n\n\n\n\n\n\nIf you closed the terminal window or made a mistake while typying your username or password do not worry. Ubuntu is already installed on your computer and you can open it from the Command Promt application.\n\n\n\n\n\nChoose a password. You will not see it as you type due to default UNIX security reasons. If not sure what you entered is correct, hold Backspace for a couple of seconds or hit Ctrl+U. That will erase everything you have written. After making sure you have entered the correct password, hit Enter. If unsure, write the password down.\n\n\n\nRe-type the chosen password and hit Enter.\n\n\n\nOnce both username and password are entered, you will see a welcome message from Ubuntu.\n\n\n\n\n\n\n\n\nThe typing line takes the new form of tunkert@LAPTOP-JU9CGB60:~$. Can you guess what the name after @ means? We will talk about what each symbol means in the terminal section.\n\n\n\n\nTo ensure that Ubuntu is up-to-date, type the following and press Enter:\n\nsudo apt update && sudo apt upgrade -y\n\n\n\n\n\n\nWe will understand the logic behind this command later in the next section as well.\n\n\n\n\n\nYou will be prompted to enter the password (Do you remember?). Enter the password—you will not see it—and press Enter.\n\n\n\nThe update will begin. In the end, you will have an empty typing line with the latest Ubuntu.\n\n\n\n\n\n\n\n\nTipDefault Command Prompt settings\n\n\n\nI suggest you make Ubuntu your Default profile. Command Promt &gt; Settings &gt; Start-up &gt; Default profile, choose Ubuntu and press Save.\n\n\nYou are now set and ready to install all the wonderful programming tools that have been developed over the past 50 or so years by the developer’s community. As you might guess, there are hundreds of thousands of programs out there, and ideally, we would like to keep track of what we install. That will be our next installation.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting-up.html#visual-studio-code",
    "href": "00_setting-up.html#visual-studio-code",
    "title": "0. Setting Up",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nVisual Studio Code, aka VS Code, has the following useful features:\n\na way to run your code interactively (line-by-line) or all at once\na way to debug (look for errors) in your code\na quick way to access helpful information about commonly used software packages\nautomatic code formatting, so that your code follows best practice guidelines\nauto-completion of your code when you hit TAB\nautomatic code checking for basic errors\ncoloring your brackets in pairs so you can keep track of the logical order of execution of your code!\n\n\n\nInstallation\nInstall VS Code from the official website (it will determine which version of the installer to use) or download installer manually here.\n\n\n\n\n\n\n\nNoteVS Code WSL extension\n\n\n\n\n\nWindows users will be promted to install the VS Code WSL extension. Agree and see Section 2.1.2.1.\n\n\n\n\n\nExtensions\nThe biggest power of VS Code lies in its extensions. They are ubiquitous allowing you to boost your IDE simply by installing what others have solved for you. You can browse them by clicking on the four cube icon on the side bar or by pressing Cmd/Ctrl+Shift+X.\n\nThere are certain basic extensions that almost every VS Code user will have installed but it can be cumbersome to manually select all those one by one. That’s how VS Code Profiles have been created.\n\nWSL Extenison (Windows users only)\nWindows user will need one more step before they can start using VS Code at its full potential. Right now, you open VS Code and all files and computation is done in Windows environment. We want VS Code to use Ubuntu that lives in WSL. Using the Visual Studio Code WSL extension VS Code will integrate Ubuntu into its environment.\nOnce the extension is installed you need to open VS Code with Ubuntu as the main environment. To do that, locate a button in the left-bottom corner of the VS Code window consisting of two stacked arrow symbols ‘&gt;’ and ‘&lt;’. Click on it.\n\nAfter clicking on this button, a promt line will appear on the top of the window. Select WSL: New WSL Window and press Enter.\n\nA new window will open. This time, notice that the corner button has changed. Now, we are running on Ubuntu.\n\nWindows users will use this environment for the course.\n\n\n\nProfiles\n\nProfiles can be used to customize VS Code for students to ease the use in a classroom setting. Profiles allow educators to quickly share a customized VS Code setup with students.\nVS Code manual\n\n\nYou can access the Profiles editor in either of the following ways: - From the Code &gt; Settings &gt; Profiles menu item\n\nFrom the Manage gear button in the bottom of the Activity Bar.\n\n\nYou will see that the Default profile is in use. We will import the GECS profile for this course. The profile file is stored on GitHub (one of its nice features). That code is shown below.\n\nHowever, you don’t need to copy it, only need the link.\nhttps://gist.github.com/igorsdub/04f6a1191dde8e09091a1099fe87d5be\nImport the GECS profile from the Profiles editor by selecting the Import Profile… button in the dropdown actions of the New Profile button.\n\nWhen you select Import Profile…, you are prompted for the URL of a GitHub gist or the file location of a profile via an Import Profile dialog. Paste the link above and click Create button below.\n\nAccept any installations or suggestions offered by extensions. Now, you are ready to go!",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting-up.html#pixi",
    "href": "00_setting-up.html#pixi",
    "title": "0. Setting Up",
    "section": "Pixi",
    "text": "Pixi\nPixi is the latest package manager and unlike its competition (e.g. Conda, Mamba, uv) supports many programming languages besides Python and is gaining momentum among software developers and scientist.\nHere we will have to use a terminal since Pixi can not be installed using a visual application, say by downloading an .exe file for Windows or .dmg for macOS.\n\n\n\n\n\n\nThat’s the reason we went to such lengths to install Ubuntu on Windows. Now, you are able to access a much larger range of applications which are inaccessible to graphical user interface (GUI) users.\n\n\n\nWe will use the VS Code’s terminal to do the installation. To open the terminal select View &gt; Terminal from the menu bar, or by pressing the Ctrl/Cmd+` keyboard shortcut. A terminal window will open at the bottom.\n\nTo install Pixi run the following command in your terminal:\ncurl -fsSL https://pixi.sh/install.sh | sh\nTo verify that Pixi got installed successfully restart the terminal. There are two ways to do so. Easy way is to kill it and open a new terminal window. Another way is to type the following for Ubuntu users:\nsource ~/.bashrc\nmacOS user need to type:\nsource ~/.zshrc\nOK, now that the terminal is reset, type:\nwhich pixi\nYou will see something like /Users/username/.pixi/bin/pixi printed, where username is your chosen username.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting-up.html#sec-github",
    "href": "00_setting-up.html#sec-github",
    "title": "0. Setting Up",
    "section": "GitHub",
    "text": "GitHub\nGitHub is a widely used platform to store, manage, share, and collaborate with others on software projects. An account is free and you can upgrade to Pro for free as a student (see the tip below). Sign up here.\n\n\n\n\n\n\nTipGitHub Education\n\n\n\n\n\nAs a student, you can get a free GitHub Pro account as part of GitHub Education alongside other perks. Once you have a basic account, follow this link.\nYou can use a photo of your student ID card (both-sides) or other eligible documents listed on here.\n\n\n\n\nMulti-factor Authentication\nSince 2023, GitHub requires all accounts to have multi-factor authentication (2FA) for extra security. Here are the recommended options:\nRecommended: Passkeys\nPasskeys are the most secure and convenient option. They work on most devices and browsers without requiring a separate app.\nOther 2FA Options:\n\nAuthenticator App (e.g., Google Authenticator, Duo Mobile) - Install on your smartphone and add GitHub\nText Message (SMS) - Receive authentication codes via text (check if your country is supported)\nHardware Security Key - Use devices like YubiKey or Google Titan\n\nFor detailed setup instructions, see GitHub’s 2FA configuration guide.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting-up.html#starship",
    "href": "00_setting-up.html#starship",
    "title": "0. Setting Up",
    "section": "Starship",
    "text": "Starship\nStarship is by far the most widely used shell prompt. It is a customizable prompt that controls how your terminal looks when you type a command. It is pretty and versatile.\n\nTo install Starship open VS Code terminal by selecting View &gt; Terminal from the menu bar, or by pressing the Ctrl/Cmd+` keyboard shortcut. A terminal window will open at the bottom. Then type:\ncurl -sS https://starship.rs/install.sh | sh\nNext, you will need to tell the terminal to start Starship every time you open a new terminal. This is similar to how Windows or macOS asks you if you want to run a program every time you start your computer.\nWindows/Ubuntu users must execute in their terminal the following:\necho 'eval \"$(starship init bash)\"' &gt;&gt; ~/.bashrc\nmacOS users have a very similar command:\necho 'eval \"$(starship init zsh)\"' &gt;&gt; ~/.zshrc\nAfter you restart the terminal, close it and open a new one, you should see the change in how it looks like. You can explore all the different looks you can access with Starship here.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting-up.html#setup-and-installation-guides",
    "href": "00_setting-up.html#setup-and-installation-guides",
    "title": "0. Setting Up",
    "section": "Setup and Installation Guides",
    "text": "Setup and Installation Guides\n\nHow to Install Ubuntu on Windows (Step-by-Step Guide for Beginners) by Subha Mondal\nWindows Subsystem for Linux Documentation",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting-up.html#tools-and-platforms",
    "href": "00_setting-up.html#tools-and-platforms",
    "title": "0. Setting Up",
    "section": "Tools and Platforms",
    "text": "Tools and Platforms\n\nVisual Studio Code\n\nVisual Studio Code Official Website\nVS Code WSL Extension Guide\nVS Code Remote WSL Documentation\nVS Code Terminal Getting Started\n\n\n\nPackage Managers\n\nPixi Official Documentation\nPixi Installation Guide\n\n\n\nShell Customization\n\nStarship Shell Prompt\nStarship Presets",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Good Enough Computing in Science (GECS)",
    "section": "",
    "text": "flowchart LR\nA[Experiment] --&gt; B[Data]\n\n%% Parallel paths (layout only)\nsubgraph Reproducible\ndirection TB\nC(**GECS**)\nend\n\nsubgraph Irreproducible\ndirection TB\nE[Ad-hoc]\nend\n\nB --&gt; C\nB --&gt; E\n\nC --&gt; G[Results]\nE --&gt; G\n\n%% Emphasize GECS edges\nlinkStyle 1 stroke-width:4px\nlinkStyle 3 stroke-width:4px\n\n%% Node styles\nclassDef gecs fill:#cfe9e5,stroke:transparent,color:#000\nclassDef adhoc fill:#eeeeee,stroke:transparent,color:#000\nclassDef neutral fill:#f7f7f7,stroke:transparent,color:#000\nclassDef results fill:#e6dff1,stroke:transparent,color:#000\n\n%% Apply styles\nclass C gecs\nclass E adhoc\nclass A,B neutral\nclass G results\n\n%% Make subgraphs invisible\nstyle Reproducible fill:transparent,stroke-width:0px\nstyle Irreproducible fill:transparent,stroke-width:0px",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#drop-in",
    "href": "index.html#drop-in",
    "title": "Good Enough Computing in Science (GECS)",
    "section": "Drop-in",
    "text": "Drop-in\nAfter every session there will be a drop-in the following week. You can come with questions or problems regarding the course.\nTime: 12:00-13:00 (Wednesdays)\nLocation: C102 (The Cafe Private Room)\nDates: Jan 21, Jan 28, Feb 4 for the Part 1; Mar 11, Mar 25, and Apr 1 for the Part 2.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#setting-up",
    "href": "index.html#setting-up",
    "title": "Good Enough Computing in Science (GECS)",
    "section": "Setting Up",
    "text": "Setting Up\nIf you need help with configuring your computer for the course, a session will be held on January 14 Wednesday at the Cafe Private Room during the lunchtime, 12:00-13:00. See Setting Up section.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Good Enough Computing in Science (GECS)",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nArthur Turrell, Greg Wilson and The Carpentries, Justin Bois, Richard McElreath, and the MulQuaBio collective.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Good Enough Computing in Science (GECS)",
    "section": "References",
    "text": "References\n\n“Good artists copy, great artists steal.”\n— Pablo Picasso\n\n\nCoding for Economists by Arthur Turrell\nPython for Data Science by Arthur Turrell\nbootcamp by Justin Bois\nResearch Software Engineering with Python by The Carpentries\nThe Multilingual Quantitative Biologist by the MulQuaBio collective",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "flowchart LR\n  A[Data] --&gt; B[Clean] --&gt; C[Analysis] --&gt; D[Results] --&gt; E[Figures] --&gt; F[Paper]\n\n  subgraph GECS[GECS]\n    direction LR\n    B\n    C\n    D\n    E\n  end\n\n  style GECS fill:#eef,stroke:#66f,stroke-width:2px\n\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n  subgraph GECS\n    direction TB\n    B1 --&gt; B2 --&gt; B3 --&gt; B1\n  end\n  A(Raw Data) --&gt; GECS --&gt; Z(Paper)"
  },
  {
    "objectID": "01_terminal.html",
    "href": "01_terminal.html",
    "title": "1. Terminal",
    "section": "",
    "text": "“Graphical user interfaces make easy tasks easy, while command line interfaces make difficult tasks possible.”\nWilliam Shotts, The Linux Command Line: A Complete Introduction\nIf there is one software skill you had to learn, it would be working with a terminal. It is ubiquitous! It has been around since 1970s and is likely to stay, unlike other tools. Thus, investing your time learning how to use it properly is worth it.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#moving-between-directories",
    "href": "01_terminal.html#moving-between-directories",
    "title": "1. Terminal",
    "section": "Moving Between Directories",
    "text": "Moving Between Directories\nTo move to a different directory, use the cd (change directory) command:\ncd /usr\npwd\nYou’re now in the /usr directory. Notice how pwd shows a different path. You can use both absolute paths (starting from the root /) and relative paths (starting from your current location).\nSome useful shortcuts for relative paths:\n\ncd . - stay in the current directory\ncd .. - go up one level to the parent directory\ncd - - go back to the previous directory\ncd ~ - go to your home directory\ncd (with no arguments) - also goes to your home directory\n\nTry these out:\ncd ..\npwd\ncd -\npwd\ncd ~\npwd",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#listing-directory-contents",
    "href": "01_terminal.html#listing-directory-contents",
    "title": "1. Terminal",
    "section": "Listing Directory Contents",
    "text": "Listing Directory Contents\nTo see what’s in your current directory, use the ls (list) command:\nls\nThis shows the files and directories in your current location. You can also list the contents of a specific directory without changing to it:\nls /usr\nls ~",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#viewing-file-contents",
    "href": "01_terminal.html#viewing-file-contents",
    "title": "1. Terminal",
    "section": "Viewing File Contents",
    "text": "Viewing File Contents\nTo see the contents of a file, you can use the cat (concatenate) command:\ncat /etc/hostname\nThis displays the contents of the file directly in the terminal.\nFor larger files, you might want to use a pager to view them one screen at a time. The less command is perfect for this:\nless /etc/profile\nInside less, you can use arrow keys to scroll, Page Up/Page Down for larger jumps, and q to quit.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#options-and-arguments",
    "href": "01_terminal.html#options-and-arguments",
    "title": "1. Terminal",
    "section": "Options and Arguments",
    "text": "Options and Arguments\nMost commands accept options (also called flags or switches) and arguments. The general format is:\ncommand -options arguments\nOptions typically start with a hyphen (-) or double hyphen (--). Let’s see this in action:\nls -l\nThe -l option shows a “long” listing with more details. Try:\nls -t\nThe -t option sorts files by modification time. You can combine multiple options:\nls -lt\nThis combines -l and -t to show details sorted by time.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#important-rules",
    "href": "01_terminal.html#important-rules",
    "title": "1. Terminal",
    "section": "Important Rules",
    "text": "Important Rules\n\n\n\n\n\n\nTry to avoid any spaces in your directory and file names. Shell interprets space as separator between options or arguments. Space in names will most likely break programs, producing errors.\nYou can use spaces by including names in parentheses or quotes, but that’s an unnecessary complication.\n\n\n\n\n\n\n\n\n\nCommands are case sensitive. ls is not the same as LS, Ls, or lS. Try it yourself!",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#directories",
    "href": "01_terminal.html#directories",
    "title": "1. Terminal",
    "section": "Directories",
    "text": "Directories\nLets create our first object using the terminal. While in your home directory ~, type:\nmkdir oist\nCheck with ls what happened. mkdir stands for make directory.\nLooks nice! Let’s go inside.\ncd oist\nAnd, check check it out.\nls\nKind of boring here. There is nothing inside. Let’s make some more directories inside.\nmkdir lab1 lab2 lab3 lab4 lab5\nThere’s something a little different about that command. So far we’ve only seen commands that work on their own (cd, pwd) or that have a single item afterwards (cd -, cd ~/Desktop/). But this time we’ve added five things after the mkdir command. Those things are referred to as parameters or arguments, and different commands can accept different numbers of arguments. The mkdir command expects at least one argument, whereas the cd command can work with zero or one, but no more. See what happens when you try to pass the wrong number of parameters to a command:\nmkdir\ncd /etc/ ~/Desktop/\nNotice that mkdir created all the folders in one directory. It didn’t create lab3/ inside lab2/ inside lab1/, or any other nested structure. But sometimes it’s handy to be able to do exactly that, and mkdir does have a way:\nmkdir -p lab4/levelE/48\nls\nYou can try to run without -p and see which error message you get.\nmkdir lab5/levelD/23\nI find this behaviour annoying. The same goes for creating files in non-existent subdirectories but I am sure there is a good reason behind such restriction.\ncd lab4\nls\ncd levelE\nls\ncd ../..\nThe “-p” that we used is called an option or a switch (in this case it means “create the parent directories, too”). Options are used to modify the way in which a command operates, allowing a single command to behave in a variety of different ways. Unfortunately, due to quirks of history and human nature, options can take different forms in different commands. You’ll often see them as single characters preceded by a hyphen (as in this case), or as longer words preceded by two hyphens. The single character form allows for multiple options to be combined, though not all commands will accept that. And to confuse matters further, some commands don’t clearly identify their options at all, whether or not something is an option is dictated purely by the order of the arguments! You don’t need to worry about all the possibilities, just know that options exist and they can take several different forms. For example the following all mean exactly the same thing:\n# These commands are equivalent\nmkdir --parents --verbose lab5/levelDE\nmkdir -p --verbose lab5/levelDE\nmkdir -p -v lab5/levelDE\nmkdir -pv lab5/levelDE",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#files",
    "href": "01_terminal.html#files",
    "title": "1. Terminal",
    "section": "Files",
    "text": "Files\nMany labs, right? Can we keep a log of them? ls just printed them but can we store this command output in a file? That’s where redirecton comes into play.\nSuppose we wanted to capture the output of that command as a text file that we can look at or manipulate further. All we need to do is to add the greater-than character (“&gt;”) to the end of our command line, followed by the name of the file to write to:\nls &gt; lab.log\nThis time there’s nothing printed to the screen, because the output is being redirected to our file instead. If you just run ls on its own you should see that the lab.log file has been created. We can use the cat command to look at its content:\ncat lab.log\nOkay, so it’s not exactly what was displayed on the screen previously, but it contains all the same data, and it’s in a more useful format for further processing.\nLet’s look at another command, echo:\necho \"VISION, CHALLENGES, INNOVATION\"\nYes, echo just prints its arguments back out again (hence the name). But combine it with a redirect, and you’ve got a way to easily create small files. Let’s redirect these words into a file that will represent the Prof. Sydney Brenner statue located at the Center Court.\n\n\n\nDr. Brenner’s statue presented by Okinawa Prefecture and the Council for Promotion of OIST https://www.oist.jp/image/dr-sydney-brenners-statue\n\n\necho \"VISION, CHALLENGES, INNOVATION\" &gt; sydney_brenner.statue\ncat sydney_brenner.statue\n\n\n\n\n\n\nImportantFile extension\n\n\n\nLinux-type systems do not care about file extensions. Files can have no extensions at all and be absolutely fine. Try redirecting the words output to file named sydney_brenner and see if you can inspect it.\n\n\nWe have one statue but why stop here? It is not improbable that Prof. Svante Pääbo will get his statute at OIST in the future. For his statue engraving we will choose something more personal.\necho \"I really wanted to discover mummies, like Indiana Jones.\" &gt; svante_paabo.statue\ncat svante_paabo.statue\nHowever, cat is more than just a file viewer - its name comes from ‘concatenate’, meaning “to link together”. If you pass more than one filename to cat it will output each of them, one after the other, as a single block of text:\ncat sydney_brenner.statue svante_paabo.statue\nWhere you want to pass multiple file names to a single command, there are some useful shortcuts that can save you a lot of typing if the files have similar names. A question mark (“?”) can be used to indicate “any single character” within the file name. An asterisk (“*”) can be used to indicate “zero or more characters”. These are sometimes referred to as “wildcard” characters. A couple of examples might help, the following commands all do the same thing:\ncat sydney_brenner.statue svante_paabo.statue\ncat *.statue\nThat is where file extension .statue that we came up with is useful. We can match all statue files no matter how many there are. lab.log has been omitted. This simple syntax makes selective manipulation of files an easy task.\n\n\n\n\n\n\nAs you might have guessed, this capability also means that you need to escape file names with “?” or “*” characters in them, too. It’s usually better to avoid any punctuation in file names if you want to manipulate them from the command line.\n\n\n\nWe have not used ? character above. A somewhat artificial example with our current setup would be to list only the lab directories and their subdirectories:\nls lab?\nThus we only look at what is inside the directories that start with “lab”.\nGoing back to the statues. Let’s join all our files together into a single new file, then view it:\ncat *.statue &gt; nobel_motivation.txt\ncat nobel_motivation.txt\nWhat do you think will happen if we run those two commands a second time? Will the computer complain, because the file already exists? Will it append the text to the file, so it contains two copies? Or will it replace it entirely? Give it a try to see what happens, but to avoid typing the commands again you can use the Up Arrow and Down Arrow keys to move back and forth through the history of commands you’ve used. Press the Up Arrow a couple of times to get to the first cat and press Enter to run it, then do the same again to get to the second.\nAs you can see, the file looks the same. That’s not because it’s been left untouched, but because the shell clears out all the content of the file before it writes the output of your cat command into it. Because of this, you should be extra careful when using redirection to make sure that you don’t accidentally overwrite a file you need. If you do want to append to, rather than replace, the content of the files, double up on the greater-than character “&gt;&gt;”:\ncat *.statue &gt;&gt; nobel_motivation.txt\necho 'I want my statue too!' &gt;&gt; nobel_motivation.txt\ncat nobel_motivation.txt\nRepeat the first cat and the echo a few more times, using the Up Arrow for convenience until your text document is so large that it won’t all fit in the terminal at once when you use cat to display it. In order to see the whole file we now need to use a different program, called a pager (because it displays your file one “page” at a time). The standard pager of old was called more, because it puts a line of text at the bottom of each page that says “–More–” to indicate that you haven’t read everything yet. These days there’s a far better pager that you should use instead: because it replaces more, the programmers decided to call it less.\nless nobel_motivation.txt\nWhen viewing a file through less you can use the Up Arrow, Down Arrow, Page Up, Page Down, Home and End keys to move through your file. Give them a try to see the difference between them. When you’ve finished viewing your file, press q to quit less and return to the command line.\n\n\n\n\n\n\nTipGood naming practice\n\n\n\nWhen you consider both case sensitivity and escaping, a good rule of thumb is to keep your file names all lower case, with only letters, numbers, underscores and hyphens. For files there’s usually also a dot and a few characters on the end to indicate the type of file it is (referred to as the “file extension”). This guideline may seem restrictive, but if you end up using the command line with any frequency you’ll be glad you stuck to this pattern.\n\n\nIf we want to move Sydney to show him the latest lab, Lab 5, how do we do that? Also, is the file we created created empty? How can we check that? ls will not work. We will see how files can be manipulated in the next section.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#renaming-files",
    "href": "01_terminal.html#renaming-files",
    "title": "1. Terminal",
    "section": "Renaming Files",
    "text": "Renaming Files\nThe mv command doesn’t just move files between directories—it’s also used to rename them. When you move a file to the same directory but give it a new name, you’re effectively renaming it.\nFor example, let’s rename one of our statue files:\nmv sydney_brenner.statue brenner_sydney.statue\ncat brenner_sydney.statue\nThe file has been renamed, not moved to a different location.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#copying-files",
    "href": "01_terminal.html#copying-files",
    "title": "1. Terminal",
    "section": "Copying Files",
    "text": "Copying Files\nSometimes you want to create a duplicate of a file. This is where the cp (copy) command comes in:\ncp brenner_sydney.statue sydney_brenner.statue\nls *.statue\nYou now have two files: the original and the last-name-first copy. The cp command can also work with directories, but you need to use an option to do so. To copy an entire directory and all its contents, use the -r option (which stands for “recursive”):\ncp -r lab4 lab0\nls\nThis creates a complete copy of lab4/ and all the files inside it, called lab0/.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#deleting-files-and-directories",
    "href": "01_terminal.html#deleting-files-and-directories",
    "title": "1. Terminal",
    "section": "Deleting Files and Directories",
    "text": "Deleting Files and Directories\nTo remove files, use the rm (remove) command. Be careful with this—once deleted, files are generally gone for good!\nrm brenner_sydney.statue\nls *.statue\nTo be honest, there is only one Lab0. To remove a directory, add the -r option:\nrm -r lab0\nls\n\n\n\n\n\n\nCautionWarning: rm is permanent\n\n\n\nUnlike moving files to a trash or recycle bin on a graphical interface, rm permanently deletes files. There is no undo! Always double-check your command before pressing Enter.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#downloading-files-from-the-web",
    "href": "01_terminal.html#downloading-files-from-the-web",
    "title": "1. Terminal",
    "section": "Downloading Files from the Web",
    "text": "Downloading Files from the Web\nAnother powerful command you encountered during the setup process is curl (Client URL). It’s used to transfer data from or to a server, often for downloading files or scripts from the internet:\ncurl -fsSL https://pixi.sh/install.sh | sh\nThis command downloads the Pixi installation script and pipes it directly to sh (the shell) for execution. Let’s break down the options:\n\n-f - Fail silently on server errors\n-s - Silent mode (don’t show progress)\n-S - Show errors even in silent mode\n-L - Follow redirects if the URL has moved\n\nYou can also use curl to download files and save them:\ncurl -O https://example.com/file.txt\nThe -O option saves the file with its original name.\n\n\n\n\n\n\nBe cautious when piping downloaded scripts directly to a shell interpreter (| sh or | bash). Only do this with scripts from trusted sources, as they will execute with your user privileges. During setup, you used this method with official installation scripts from Pixi and Starship.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#reloading-configuration-files",
    "href": "01_terminal.html#reloading-configuration-files",
    "title": "1. Terminal",
    "section": "Reloading Configuration Files",
    "text": "Reloading Configuration Files\nWhen you modify configuration files like .bashrc or .zshrc, the changes won’t take effect until you start a new terminal session. However, you can reload the configuration without closing your terminal using the source command:\nsource ~/.bashrc\nOr for Zsh users:\nsource ~/.zshrc\nThis reads and executes the commands from the specified file in your current shell session. You used this command during setup to activate Pixi after installation.\n\n\n\n\n\n\nYou can view the contents of your configuration files using cat ~/.bashrc or less ~/.bashrc to see what customizations you’ve made.\n\n\n\nAs you progress through more advanced topics, you’ll encounter many more hidden files and directories. Configuration files, cache directories, and version control metadata (like .git/) all use the dot-prefix convention. This naming strategy keeps your file system organized and separates system/application configuration from your regular working files. In future lessons, we’ll explore how these hidden files and directories make it very convenient to manage complex configurations without cluttering your workspace.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "03_version-control.html",
    "href": "03_version-control.html",
    "title": "3. Version Control",
    "section": "",
    "text": "If I could turn back time\nCher, If I Could Turn Back Time 1989\nVersion control tracks changes to your files, lets you undo mistakes, and makes collaboration easy. Once you start using it, you’ll wonder how you worked without it!",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#installing-git",
    "href": "03_version-control.html#installing-git",
    "title": "3. Version Control",
    "section": "Installing Git",
    "text": "Installing Git\nYou should have Git already installed in your distribution. Check it out by typing in your terminal:\ngit --version\nIf you get an error, please see this webpage from The Software Carpentries for instructions on installing Git for various operating systems.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#creating-github-account",
    "href": "03_version-control.html#creating-github-account",
    "title": "3. Version Control",
    "section": "Creating GitHub Account",
    "text": "Creating GitHub Account\nIf you don’t already have a GitHub account, check the Setting Up section.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#preparing-your-working-directory",
    "href": "03_version-control.html#preparing-your-working-directory",
    "title": "3. Version Control",
    "section": "Preparing Your Working Directory",
    "text": "Preparing Your Working Directory\nYou can choose which directory you want to work in. If you have no preference, move to your home directory:\ncd",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#places-to-create-git-repositories",
    "href": "03_version-control.html#places-to-create-git-repositories",
    "title": "3. Version Control",
    "section": "Places to Create Git Repositories",
    "text": "Places to Create Git Repositories\nAlong with tracking information about recipes (the project we have already created), Alfredo would also like to track information about desserts specifically. Alfredo creates a desserts project inside his recipes project with the following sequence of commands:\ncd              # return to the home directory\ncd recipes      # go into recipes directory, which is already a Git repository\nls -a           # ensure the .git subdirectory is still present in the recipes directory\nmkdir desserts  # make a sub-directory recipes/desserts\ncd desserts     # go into desserts subdirectory\ngit init        # make the desserts subdirectory a Git repository\nls -a           # ensure the .git subdirectory is present indicating we have created a new Git repository\nIs the git init command, run inside the desserts subdirectory, required for tracking files stored in the desserts subdirectory?\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n**No. Alfredo does not need to make the desserts subdirectory a Git repository because the recipes repository will track all files, sub-directories, and subdirectory files under the recipes directory. Thus, in order to track all information about desserts, Alfredo only needed to add the desserts subdirectory to the recipes directory.\nRight now, you have a “nested repository” is a Git repository that exists within the working directory of another Git repository. Each nested repository operates independently with its own history. Git is designed primarily to manage one repository per directory tree. When Git encounters a .git folder within a subdirectory of a parent repository, it treats the inner repository as a separate entity and usually ignores its contents within the parent’s version control.\nYo**u can verify that the desserts subdirectory is not being tracked by the recipes repository by running the following command from within the recipes directory:\ntouch tiramisu.md # create a new file in recipes directory\ngit status        # check the status of the recipes repository\ncd ..             # go back to recipes directory  \ngit status        # check the status of the desserts repository\nTo delete unwanted nested repositories, simply delete the .git subdirectory inside the unwanted repository while in the parent repository. For example, to delete the unwanted desserts repository, Alfredo would run:\ncd desserts\nrm -rf .git\ngit status\nand then return to the recipes directory:\ncd ..",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#choosing-a-commit-message",
    "href": "03_version-control.html#choosing-a-commit-message",
    "title": "3. Version Control",
    "section": "Choosing a Commit Message",
    "text": "Choosing a Commit Message\nWhich of the following commit messages would be most appropriate for the last commit made to guacamole.md?\n\n“Changes”\n“Change lemon for lime”\n“Modify guacamole to the traditional recipe”\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nAnswer 3. Good commit messages are short, descriptive, and explain why, not just what.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#committing-changes-to-git",
    "href": "03_version-control.html#committing-changes-to-git",
    "title": "3. Version Control",
    "section": "Committing Changes to Git",
    "text": "Committing Changes to Git\nWhich command(s) below would save the changes of myfile.txt to my local Git repository?\n\ngit commit -m \"my recent changes\"\ngit init myfile.txt then git commit -m \"my recent changes\"\ngit add myfile.txt then git commit -m \"my recent changes\"\ngit commit -m myfile.txt \"my recent changes\"\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nAnswer 3 is correct: git add stages the file, then git commit saves it.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#committing-multiple-files",
    "href": "03_version-control.html#committing-multiple-files",
    "title": "3. Version Control",
    "section": "Committing Multiple Files",
    "text": "Committing Multiple Files\nYou can group changes from multiple files into one commit. Use git add file1.txt file2.txt to stage multiple files, then commit them together.\n\nAdd some text to guacamole.md noting the rough price of the ingredients.\nCreate a new file groceries.md with a list of products and their prices for different markets.\nAdd changes from both files to the staging area, and commit those changes.\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nFirst we make our changes to the guacamole.md and groceries.md files:\ncat guacamole.md\n# Guacamole\n## Ingredients\n* avocado (1.35)\n* lime (0.64)\n* salt (2)\ncat groceries.md\n# Market A\n* avocado: 1.35 per unit.\n* lime: 0.64 per unit\n* salt: 2 per kg\nNow you can add both files to the staging area. We can do that in one line:\ngit add guacamole.md groceries.md\nOr with multiple commands:\ngit add guacamole.md\ngit add groceries.md\nNow the files are ready to commit. You can check that using git status. If you are ready to commit use:\ngit commit -m \"Write prices for ingredients and their source\"\n[main cc127c2]\n Write prices for ingredients and their source\n 2 files changed, 7 insertions(+)\n create mode 100644 groceries.md",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#bio-repository",
    "href": "03_version-control.html#bio-repository",
    "title": "3. Version Control",
    "section": "bio Repository",
    "text": "bio Repository\n\nCreate a new Git repository on your computer called bio.\nWrite a three-line biography for yourself in a file called me.txt, commit your changes\nModify one line, add a fourth line\nDisplay the differences between its updated state and its original state.\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nIf needed, move out of the recipes folder:\ncd ..\nCreate a new folder called bio and ‘move’ into it:\nmkdir bio\ncd bio\nInitialise git:\ngit init\nCreate your biography file me.txt using VS Code or another text editor. Once in place, add and commit it to the repository:\ngit add me.txt\ngit commit -m \"Add biography file\"\nModify the file as described (modify one line, add a fourth line). To display the differences between its updated state and its original state, use git diff:\ngit diff me.txt",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#recovering-older-versions-of-a-file",
    "href": "03_version-control.html#recovering-older-versions-of-a-file",
    "title": "3. Version Control",
    "section": "Recovering Older Versions of a File",
    "text": "Recovering Older Versions of a File\nJennifer has made changes to the Python script that she has been working on for weeks, and the modifications she made this morning “broke” the script and it no longer runs. She has spent approximately 1 hour trying to fix it, with no luck…\nLuckily, she has been keeping track of her project’s versions using Git! Which commands below will let her recover the last committed version of her Python script called data_cruncher.py?\n\ngit restore\ngit restore data_cruncher.py\ngit restore -s HEAD~1 data_cruncher.py\ngit restore -s &lt;unique ID of last commit&gt; data_cruncher.py\nBoth 2 and 4\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nThe answer is (5) - Both 2 and 4.\nThe restore command restores files from the repository, overwriting the files in your working directory. Answers 2 and 4 both restore the latest version in the repository of the file data_cruncher.py. Answer 2 uses HEAD to indicate the latest, whereas answer 4 uses the unique ID of the last commit, which is what HEAD means.\nAnswer 3 gets the version of data_cruncher.py from the commit before HEAD, which is NOT what we wanted.\nAnswer 1 results in an error. You need to specify a file to restore. If you want to restore all files you should use git restore .",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#understanding-workflow-and-history",
    "href": "03_version-control.html#understanding-workflow-and-history",
    "title": "3. Version Control",
    "section": "Understanding Workflow and History",
    "text": "Understanding Workflow and History\nWhat is the output of the last command in the following sequence?\ncd recipes\necho \"I like tomatoes, therefore I like ketchup\" &gt; ketchup.md\ngit add ketchup.md\necho \"ketchup enhances pasta dishes\" &gt;&gt; ketchup.md\ngit commit -m \"My opinions about the red sauce\"\ngit restore ketchup.md\ncat ketchup.md\n\n   ketchup enhances pasta dishes\n   I like tomatoes, therefore I like ketchup\n   I like tomatoes, therefore I like ketchup\n   ketchup enhances pasta dishes\n   Error because you have changed ketchup.md without committing the changes\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nThe answer is 2.\nThe changes to the file from the second echo command are only applied to the working copy, not the version in the staging area. The command git add ketchup.md places the current version of ketchup.md into the staging area.\nSo, when git commit -m \"My opinions about the red sauce\" is executed, the version of ketchup.md committed to the repository is the one from the staging area and has only one line.\nAt this time, the working copy still has the second line (and git status will show that the file is modified). However, git restore ketchup.md replaces the working copy with the most recently committed version of ketchup.md. So, cat ketchup.md will output:\nI like tomatoes, therefore I like ketchup",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#understanding-of-git-diff",
    "href": "03_version-control.html#understanding-of-git-diff",
    "title": "3. Version Control",
    "section": "Understanding of git diff",
    "text": "Understanding of git diff\nConsider this command: git diff HEAD~9 guacamole.md. What do you predict this command will do if you execute it? What happens when you do execute it? Why?\nTry another command, git diff [ID] guacamole.md, where [ID] is replaced with the unique identifier for your most recent commit. What do you think will happen, and what does happen?",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#getting-rid-of-staged-changes",
    "href": "03_version-control.html#getting-rid-of-staged-changes",
    "title": "3. Version Control",
    "section": "Getting Rid of Staged Changes",
    "text": "Getting Rid of Staged Changes\ngit restore can be used to restore a previous commit when unstaged changes have been made, but will it also work for changes that have been staged but not committed? Make a change to guacamole.md, add that change using git add, then use git restore to see if you can remove your change.\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nAfter adding a change, git restore cannot be used directly. Let’s look at the output of git status:\nOn branch main\nChanges to be committed:\n  (use \"git restore --staged &lt;file&gt;...\" to unstage)\n        modified:   guacamole.md\nNote that if you don’t have the same output, you may either have forgotten to change the file, or you have added it and committed it.\nUsing the command git restore guacamole.md now does not give an error, but it does not restore the file either. Git helpfully tells us that we need to use git restore --staged first to unstage the file:\ngit restore --staged guacamole.md\nNow, git status gives us:\ngit status\nOn branch main\nChanges not staged for commit:\n  (use \"git add &lt;file&gt;...\" to update what will be committed)\n  (use \"git restore &lt;file&gt;...\" to discard changes in working directory)\n        modified:   guacamole.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\nThis means we can now use git restore to restore the file to the previous commit:\ngit restore guacamole.md\ngit status\nOn branch main\nnothing to commit, working tree clean",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#explore-and-summarize-histories",
    "href": "03_version-control.html#explore-and-summarize-histories",
    "title": "3. Version Control",
    "section": "Explore and Summarize Histories",
    "text": "Explore and Summarize Histories\nExploring history is an important part of Git, and often it is a challenge to find the right commit ID, especially if the commit is from several months ago.\nImagine the recipes project has more than 50 files. You would like to find a commit that modifies some specific text in guacamole.md. When you type git log, a very long list appeared. How can you narrow down the search?\nRecall that the git diff command allows us to explore one specific file, e.g., git diff guacamole.md. We can apply a similar idea here.\ngit log guacamole.md\nUnfortunately some of these commit messages are very ambiguous, e.g., update files. How can you search through these files?\nBoth git diff and git log are very useful and they summarize a different part of the history for you. Is it possible to combine both? Let’s try the following:\ngit log --patch guacamole.md\nYou should get a long list of output, and you should be able to see both commit messages and the difference between each commit.\nQuestion: What does the following command do?\ngit log --patch HEAD~9 *.md",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#ignoring-nested-files",
    "href": "03_version-control.html#ignoring-nested-files",
    "title": "3. Version Control",
    "section": "Ignoring Nested Files",
    "text": "Ignoring Nested Files\nGiven a directory structure that looks like:\npictures/cake\npictures/pizza\nHow would you ignore only pictures/cake and not pictures/pizza?\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nIf you only want to ignore the contents of pictures/cake, you can change your .gitignore to ignore only the /cake/ subfolder by adding the following line to your .gitignore:\npictures/cake/\nThis line will ensure only the contents of pictures/cake is ignored, and not the contents of pictures/pizza.\nAs with most programming issues, there are a few alternative ways that one may ensure this ignore rule is followed. Further, the discussion pages have more detail on ignore rules.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#including-specific-files",
    "href": "03_version-control.html#including-specific-files",
    "title": "3. Version Control",
    "section": "Including Specific Files",
    "text": "Including Specific Files\nHow would you ignore all .png files in your root directory except for final.png?\nHint: Find out what ! (the exclamation point operator) does\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nYou would add the following two lines to your .gitignore:\n*.png           # ignore all png files\n!final.png      # except final.png\nThe exclamation point operator will include a previously excluded entry.\nNote also that, if you’ve previously committed .png files in this lesson, they will not be ignored with this new rule. Only future additions of .png files to the root directory will be ignored.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#ignoring-nested-files-variation",
    "href": "03_version-control.html#ignoring-nested-files-variation",
    "title": "3. Version Control",
    "section": "Ignoring Nested Files: Variation",
    "text": "Ignoring Nested Files: Variation\nGiven a directory structure that looks similar to the earlier Nested Files exercise, but with a slightly different directory structure:\npictures/cake\npictures/pizza\npictures/pie\npictures/brownie\nHow would you ignore all of the contents in the pictures folder, but not pictures/pie?\nHint: think a bit about how you created an exception with the ! operator before.\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nIf you want to ignore the contents of pictures/ but not those of pictures/pie/, you can change your .gitignore to ignore the contents of pictures folder, but create an exception for the contents of the pictures/pie subfolder. Your .gitignore would look like this:\npictures/*              # ignore everything in pictures folder\n!pictures/pie/          # do not ignore pictures/pie/ contents",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#ignoring-all-data-files-in-a-directory",
    "href": "03_version-control.html#ignoring-all-data-files-in-a-directory",
    "title": "3. Version Control",
    "section": "Ignoring all data Files in a Directory",
    "text": "Ignoring all data Files in a Directory\nAssuming you have an empty .gitignore file, and given a directory structure that looks like:\npictures/data/location/gps/a.dat\npictures/data/location/gps/b.dat\npictures/data/location/gps/c.dat\npictures/data/location/gps/info.txt\npictures/plots\nWhat’s the shortest .gitignore rule you could write to ignore all .dat files in pictures/data/location/gps? Do not ignore the info.txt.\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nAppending pictures/data/location/gps/*.dat will match every file in pictures/data/location/gps that ends with .dat. The file pictures/data/location/gps/info.txt will not be ignored.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#ignoring-all-data-files-in-the-repository",
    "href": "03_version-control.html#ignoring-all-data-files-in-the-repository",
    "title": "3. Version Control",
    "section": "Ignoring all data Files in the repository",
    "text": "Ignoring all data Files in the repository\nLet us assume you have many .csv files in different subdirectories of your repository. For example, you might have:\nresults/a.csv\ndata/experiment_1/b.csv\ndata/experiment_2/c.csv\ndata/experiment_2/variation_1/d.csv\nHow do you ignore all the .csv files, without explicitly listing the names of the corresponding folders?\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nIn the .gitignore file, write:\n**/*.csv\nThis will ignore all the .csv files, regardless of their position in the directory tree. You can still include some specific exception with the exclamation point operator.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#the-order-of-rules",
    "href": "03_version-control.html#the-order-of-rules",
    "title": "3. Version Control",
    "section": "The Order of Rules",
    "text": "The Order of Rules\nGiven a .gitignore file with the following contents:\n*.csv\n!*.csv\nWhat will be the result?\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nThe ! modifier will negate an entry from a previously defined ignore pattern. Because the !*.csv entry negates all of the previous .csv files in the .gitignore, none of them will be ignored, and all .csv files will be tracked.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#log-files",
    "href": "03_version-control.html#log-files",
    "title": "3. Version Control",
    "section": "Log Files",
    "text": "Log Files\nYou wrote a script that creates many intermediate log-files of the form log_01, log_02, log_03, etc. You want to keep them but you do not want to track them through git.\n\nWrite one .gitignore entry that excludes files of the form log_01, log_02, etc.\nTest your “ignore pattern” by creating some dummy files of the form log_01, etc.\nYou find that the file log_01 is very important after all, add it to the tracked files without changing the .gitignore again.\nDiscuss with your neighbor what other types of files could reside in your directory that you do not want to track and thus would exclude via .gitignore.\n\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\n\nAppend either log_* or log* as a new entry in your .gitignore\nTrack log_01 using git add -f log_01",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#creating-a-remote-repository",
    "href": "03_version-control.html#creating-a-remote-repository",
    "title": "3. Version Control",
    "section": "Creating a remote repository",
    "text": "Creating a remote repository\nLog in to GitHub, then click on the icon in the top right corner to create a new repository called recipes.\nName your repository “recipes” and then click “Create Repository”.\n\n\n\n\n\n\nCreate an empty repository on GitHub. Don’t initialize it with a README or license.\n\n\n\nAs soon as the repository is created, GitHub displays a page with a URL and some information on how to configure your local repository. This effectively does the following on GitHub’s servers:\nmkdir recipes\ncd recipes\ngit init\nIf you remember back to the earlier episode where we added and committed our work on guacamole.md, we had a diagram of the local repository. Now that we have two repositories, we need to connect them.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#connecting-local-to-remote-repository",
    "href": "03_version-control.html#connecting-local-to-remote-repository",
    "title": "3. Version Control",
    "section": "Connecting local to remote repository",
    "text": "Connecting local to remote repository\nNow we connect the two repositories. We do this by making the GitHub repository a remote for the local repository. The home page of the repository on GitHub includes the URL string we need to identify it. Click on the ‘SSH’ link to change the protocol from HTTPS to SSH.\n\n\n\n\n\n\nNoteHTTPS vs. SSH\n\n\n\nSSH is more secure. Use SSH for GitHub authentication.\n\n\nCopy that URL from the browser, go into the local recipes repository, and run this command:\ngit remote add origin git@github.com:alflin/recipes.git\nMake sure to use the URL for your repository rather than Alfredo’s: the only difference should be your username instead of alflin.\norigin is a local name used to refer to the remote repository. It could be called anything, but origin is a convention that is often used by default in git and GitHub, so it’s helpful to stick with this unless there’s a reason not to.\nWe can check that the command has worked by running git remote -v:\ngit remote -v\norigin   git@github.com:alflin/recipes.git (fetch)\norigin   git@github.com:alflin/recipes.git (push)",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#ssh-background-and-setup",
    "href": "03_version-control.html#ssh-background-and-setup",
    "title": "3. Version Control",
    "section": "SSH Background and Setup",
    "text": "SSH Background and Setup\nSSH (Secure Shell Protocol) allows secure communication. SSH uses a key pair: a public key (like a padlock) shared with GitHub, and a private key (the only key to open it) kept on your computer. GitHub authenticates you using these keys.\nWhat we will do now is the minimum required to set up the SSH keys and add the public key to a GitHub account.\nThe first thing we are going to do is check if this has already been done on the computer you’re on. Because generally speaking, this setup only needs to happen once and then you can forget about it.\n\n\n\n\n\n\nTipKeeping your keys secure\n\n\n\nCheck your SSH keys periodically to ensure they’re current and secure.\n\n\nWe will run the list command to check what key pairs already exist on your computer.\nls -al ~/.ssh\nYour output is going to look a little different depending on whether or not SSH has ever been set up on the computer you are using.\nIf SSH has not been set up, your output is:\nls: cannot access '~/.ssh': No such file or directory\nIf SSH has been set up on the computer you’re using, the public and private key pairs will be listed. The file names are either id_ed25519/id_ed25519.pub or id_rsa/id_rsa.pub depending on how the key pairs were set up.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#creating-an-ssh-key-pair",
    "href": "03_version-control.html#creating-an-ssh-key-pair",
    "title": "3. Version Control",
    "section": "Creating an SSH key pair",
    "text": "Creating an SSH key pair\nTo create an SSH key pair use this command, where the -t option specifies which type of algorithm to use and -C attaches a comment to the key (here, your email):\nssh-keygen -t ed25519 -C \"a.linguini@ratatouille.fr\"\nIf you are using a legacy system that doesn’t support the Ed25519 algorithm, use:\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/c/Users/Alfredo/.ssh/id_ed25519):\nWe want to use the default file, so just press Enter.\nCreated directory '/c/Users/Alfredo/.ssh'.\nEnter passphrase (empty for no passphrase):\nNow, it is prompting you for a passphrase. Since you might be using a shared laptop, you want to create a passphrase. Be sure to use something memorable or save your passphrase somewhere, as there is no “reset my password” option. Note that when typing a passphrase on a terminal, there won’t be any visual feedback of your typing. This is normal: your passphrase will be recorded even if you see nothing changing on your screen.\nEnter same passphrase again:\nAfter entering the same passphrase a second time, you receive the confirmation:\nYour identification has been saved in /c/Users/Alfredo/.ssh/id_ed25519\nYour public key has been saved in /c/Users/Alfredo/.ssh/id_ed25519.pub\nThe key fingerprint is:\nSHA256:SMSPIStNyA00KPxuYu94KpZgRAYjgt9g4BA4kFy3g1o a.linguini@ratatouille.fr\nThe key's randomart image is:\n+--[ED25519 256]--+\n|^B== o.          |\n|%*=.*.+          |\n|+=.E =.+         |\n| .=.+.o..        |\n|....  . S        |\n|.+ o             |\n|+ =              |\n|.o.o             |\n|oo+.             |\n+----[SHA256]-----+\nThe “identification” is actually the private key. You should never share it. The public key is appropriately named. The “key fingerprint” is a shorter version of a public key.\nNow that you have generated the SSH keys, you will find the SSH files when you check:\nls -al ~/.ssh\ndrwxr-xr-x 1 Alfredo   197121   0 Jul 16 14:48 ./\ndrwxr-xr-x 1 Alfredo   197121   0 Jul 16 14:48 ../\n-rw-r--r-- 1 Alfredo   197121 419 Jul 16 14:48 id_ed25519\n-rw-r--r-- 1 Alfredo   197121 106 Jul 16 14:48 id_ed25519.pub",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#copying-the-public-key-to-github",
    "href": "03_version-control.html#copying-the-public-key-to-github",
    "title": "3. Version Control",
    "section": "Copying the public key to GitHub",
    "text": "Copying the public key to GitHub\nNow you have an SSH key pair and you can run this command to check if GitHub can read your authentication:\nssh -T git@github.com\nThe authenticity of host 'github.com (192.30.255.112)' can't be established.\nRSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.\nThis key is not known by any other names\nAre you sure you want to continue connecting (yes/no/[fingerprint])? yes\nWarning: Permanently added 'github.com' (RSA) to the list of known hosts.\ngit@github.com: Permission denied (publickey).\nRight, we forgot that we need to give GitHub our public key!\nFirst, we need to copy the public key. Be sure to include the .pub at the end, otherwise you’re looking at the private key.\ncat ~/.ssh/id_ed25519.pub\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIDmRA3d51X0uu9wXek559gfn6UFNF69yZjChyBIU2qKI a.linguini@ratatouille.fr\nNow, going to GitHub.com, click on your profile icon in the top right corner to get the drop-down menu. Click “Settings”, then on the settings page, click “SSH and GPG keys” on the left side “Access” menu. Click the “New SSH key” button on the right side. Now, you can add the title (use something descriptive like “My Laptop” so you can remember where the original key pair files are located), paste your SSH key into the field, and click the “Add SSH key” to complete the setup.\nNow that you’ve set that up, let’s check your authentication again from the command line:\nssh -T git@github.com\nHi Alfredo! You've successfully authenticated, but GitHub does not provide shell access.\nGood! This output confirms that the SSH key works as intended. You are now ready to push your work to the remote repository.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#pushing-local-changes-to-a-remote",
    "href": "03_version-control.html#pushing-local-changes-to-a-remote",
    "title": "3. Version Control",
    "section": "Pushing local changes to a remote",
    "text": "Pushing local changes to a remote\nNow that authentication is set up, we can return to the remote. This command will push the changes from our local repository to the repository on GitHub:\ngit push origin main\nIf you set up a passphrase, it will prompt you for it. If you completed advanced settings for your authentication, it will not prompt for a passphrase.\nEnumerating objects: 16, done.\nCounting objects: 100% (16/16), done.\nDelta compression using up to 8 threads.\nCompressing objects: 100% (11/11), done.\nWriting objects: 100% (16/16), 1.45 KiB | 372.00 KiB/s, done.\nTotal 16 (delta 2), reused 0 (delta 0)\nremote: Resolving deltas: 100% (2/2), done.\nTo https://github.com/alflin/recipes.git\n * [new branch]      main -&gt; main\nWe can pull changes from the remote repository to the local one as well:\ngit pull origin main\nFrom https://github.com/alflin/recipes\n * branch            main     -&gt; FETCH_HEAD\nAlready up to date.\nPulling has no effect in this case because the two repositories are already synchronized. If someone else had pushed some changes to the repository on GitHub, though, this command would download them to our local repository.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#github-gui",
    "href": "03_version-control.html#github-gui",
    "title": "3. Version Control",
    "section": "GitHub GUI",
    "text": "GitHub GUI\nBrowse to your recipes repository on GitHub. Under the Code tab, find and click on the text that says “XX commits” (where “XX” is some number). Hover over, and click on, the three buttons to the right of each commit. What information can you gather/explore from these buttons? How would you get that same information in the shell?\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nWhen you click on the left-most button, you’ll see all of the changes that were made in that particular commit. Green shaded lines indicate additions and red ones removals. In the shell we can do the same thing with git diff. In particular, git diff ID1..ID2 where ID1 and ID2 are commit identifiers (e.g. git diff a3bf1e5..041e637) will show the differences between those two commits.\nThe middle button (with the picture of two overlapping squares or pages) copies the full identifier of the commit to the clipboard. In the shell, git log will show you the full commit identifier for each commit.\nThe right-most button lets you view all of the files in the repository at the time of that commit. To do this in the shell, we’d need to checkout the repository at that particular time. We can do this with git checkout ID where ID is the identifier of the commit we want to look at. If we do this, we need to remember to put the repository back to the right state afterwards!",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#github-timestamp",
    "href": "03_version-control.html#github-timestamp",
    "title": "3. Version Control",
    "section": "GitHub Timestamp",
    "text": "GitHub Timestamp\nCreate a remote repository on GitHub. Push the contents of your local repository to the remote. Make changes to your local repository and push these changes. Go to the repo you just created on GitHub and check the timestamps of the files. How does GitHub record times, and why?\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nGitHub displays timestamps in a human readable relative format (i.e. “22 hours ago” or “three weeks ago”). However, if you hover over the timestamp, you can see the exact time at which the last change to the file occurred.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#push-vs.-commit",
    "href": "03_version-control.html#push-vs.-commit",
    "title": "3. Version Control",
    "section": "Push vs. Commit",
    "text": "Push vs. Commit\nIn this episode, we introduced the git push command. How is git push different from git commit?\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nWhen we push changes, we’re interacting with a remote repository to update it with the changes we’ve made locally (often this corresponds to sharing the changes we’ve made with others). Commit only updates your local repository.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#adding-collaborators",
    "href": "03_version-control.html#adding-collaborators",
    "title": "3. Version Control",
    "section": "Adding collaborators",
    "text": "Adding collaborators\nThe repository owner needs to give other people access. In your repository page on GitHub, click the “Settings” button on the right, select “Collaborators”, click “Add people”, and then enter your collaborator’s username.\nTo accept access to the owner’s repository, the collaborator needs to go to https://github.com/notifications or check for email notification. Once there, they can accept access to the owner’s repository.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#cloning-a-repository",
    "href": "03_version-control.html#cloning-a-repository",
    "title": "3. Version Control",
    "section": "Cloning a repository",
    "text": "Cloning a repository\nNext, the collaborator needs to download a copy of the owner’s repository to their machine. This is called “cloning a repo”.\nThe collaborator doesn’t want to overwrite their own version of recipes.git, so they need to clone the owner’s repository to a different location than their own repository with the same name.\nTo clone the owner’s repo into the home directory ~, the collaborator enters:\ngit clone git@github.com:alflin/recipes.git ~/alflin-recipes\nReplace ‘alflin’ with the owner’s username.\n\n\n\n\n\n\nNoteImportant\n\n\n\nIf you choose to clone without the clone path (~/alflin-recipes) specified at the end, you will clone inside your own recipes folder! Make sure to navigate to the home directory first.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#making-changes-as-a-collaborator",
    "href": "03_version-control.html#making-changes-as-a-collaborator",
    "title": "3. Version Control",
    "section": "Making changes as a collaborator",
    "text": "Making changes as a collaborator\nThe collaborator can now make a change in their clone of the owner’s repository, exactly the same way as we’ve been doing before:\ncd ~/alflin-recipes\ncode hummus.md\ncat hummus.md\n# Hummus\n## Ingredients\n* chickpeas\n* lemon\n* olive oil\n* salt\ngit add hummus.md\ngit commit -m \"Add ingredients for hummus\"\n 1 file changed, 6 insertion(+)\n create mode 100644 hummus.md\nThen push the change to the owner’s repository on GitHub:\ngit push origin main\nEnumerating objects: 4, done.\nCounting objects: 4, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 306 bytes, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo https://github.com/alflin/recipes.git\n   9272da5..29aba7c  main -&gt; main\nNote that we didn’t have to create a remote called origin: Git uses this name by default when we clone a repository. (This is why origin was a sensible choice earlier when we were setting up remotes by hand.)\nTake a look at the owner’s repository on GitHub again, and you should be able to see the new commit made by the collaborator. You may need to refresh your browser to see the new commit.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#understanding-remotes",
    "href": "03_version-control.html#understanding-remotes",
    "title": "3. Version Control",
    "section": "Understanding remotes",
    "text": "Understanding remotes\nA remote is a copy of your repository hosted elsewhere (like GitHub). origin is the default remote name. Use git remote -v to list your remotes.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#pulling-changes-from-a-collaborator",
    "href": "03_version-control.html#pulling-changes-from-a-collaborator",
    "title": "3. Version Control",
    "section": "Pulling changes from a collaborator",
    "text": "Pulling changes from a collaborator\nTo download the collaborator’s changes from GitHub, the owner now enters:\ngit pull origin main\nremote: Enumerating objects: 4, done.\nremote: Counting objects: 100% (4/4), done.\nremote: Compressing objects: 100% (2/2), done.\nremote: Total 3 (delta 0), reused 3 (delta 0), pack-reused 0\nUnpacking objects: 100% (3/3), done.\nFrom https://github.com/alflin/recipes\n * branch            main     -&gt; FETCH_HEAD\n   9272da5..29aba7c  main     -&gt; origin/main\nUpdating 9272da5..29aba7c\nFast-forward\n hummus.md | 5 +\n 1 file changed, 5 insertion(+)\n create mode 100644 hummus.md\nNow the three repositories (owner’s local, collaborator’s local, and owner’s on GitHub) are back in sync.\n\n\n\n\n\n\nNoteA Basic Collaborative Workflow\n\n\n\n\n\nIn practice, it is good to be sure that you have an updated version of the repository you are collaborating on, so you should git pull before making changes. The basic collaborative workflow would be:\n\nupdate your local repo with git pull origin main,\nmake your changes and stage them with git add,\ncommit your changes with git commit -m, and\nupload the changes to GitHub with git push origin main\n\nIt is better to make many commits with smaller changes rather than one commit with massive changes: small commits are easier to read and review.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#switch-roles-and-repeat",
    "href": "03_version-control.html#switch-roles-and-repeat",
    "title": "3. Version Control",
    "section": "Switch Roles and Repeat",
    "text": "Switch Roles and Repeat\nSwitch roles with your partner and repeat the whole process. One person should now be the collaborator making changes to the other person’s repository.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#review-changes",
    "href": "03_version-control.html#review-changes",
    "title": "3. Version Control",
    "section": "Review Changes",
    "text": "Review Changes\nThe owner pushed commits to the repository without giving any information to the collaborator. How can the collaborator find out what has changed with the command line? And on GitHub?\n\n\n\n\n\n\nNoteSolution\n\n\n\n\n\nOn the command line, the collaborator can use git fetch origin main to get the remote changes into the local repository, but without merging them. Then by running git diff main origin/main the collaborator will see the changes output in the terminal.\nOn GitHub, the collaborator can go to the repository and click on “commits” to view the most recent commits pushed to the repository.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#comment-changes-in-github",
    "href": "03_version-control.html#comment-changes-in-github",
    "title": "3. Version Control",
    "section": "Comment Changes in GitHub",
    "text": "Comment Changes in GitHub\nThe collaborator has some questions about one line change made by the owner and has some suggestions to propose.\nWith GitHub, it is possible to comment on the diff of a commit. Over the line of code to comment, a blue comment icon appears to open a comment window.\nThe collaborator posts their comments and suggestions using the GitHub interface.",
    "crumbs": [
      "3. Version Control"
    ]
  },
  {
    "objectID": "03_version-control.html#version-history-backup-and-version-control",
    "href": "03_version-control.html#version-history-backup-and-version-control",
    "title": "3. Version Control",
    "section": "Version History, Backup, and Version Control",
    "text": "Version History, Backup, and Version Control\nSome backup software can keep a history of the versions of your files. They also allow you to recover specific versions. How is this functionality different from version control? What are some of the benefits of using version control, Git, and GitHub?",
    "crumbs": [
      "3. Version Control"
    ]
  }
]