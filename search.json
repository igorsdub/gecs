[
  {
    "objectID": "01_terminal.html",
    "href": "01_terminal.html",
    "title": "1. Terminal",
    "section": "",
    "text": "“Graphical user interfaces make easy tasks easy, while command line interfaces make difficult tasks possible.”\n\nWilliam Shotts, The Linux Command Line: A Complete Introduction\nIf there is one software skill you had to learn, it would be working with a terminal. It is ubiquitous! It has been around since 1970s and is likely to stay, unlike other tools. Thus, investing your time learning how to use it properly is worth it.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#moving-between-directories",
    "href": "01_terminal.html#moving-between-directories",
    "title": "1. Terminal",
    "section": "Moving Between Directories",
    "text": "Moving Between Directories\nTo move to a different directory, use the cd (change directory) command:\ncd /usr\npwd\nYou’re now in the /usr directory. Notice how pwd shows a different path. You can use both absolute paths (starting from the root /) and relative paths (starting from your current location).\nSome useful shortcuts for relative paths:\n\ncd . - stay in the current directory\ncd .. - go up one level to the parent directory\ncd - - go back to the previous directory\ncd ~ - go to your home directory\ncd (with no arguments) - also goes to your home directory\n\nTry these out:\ncd ..\npwd\ncd -\npwd\ncd ~\npwd",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#listing-directory-contents",
    "href": "01_terminal.html#listing-directory-contents",
    "title": "1. Terminal",
    "section": "Listing Directory Contents",
    "text": "Listing Directory Contents\nTo see what’s in your current directory, use the ls (list) command:\nls\nThis shows the files and directories in your current location. You can also list the contents of a specific directory without changing to it:\nls /usr\nls ~",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#viewing-file-contents",
    "href": "01_terminal.html#viewing-file-contents",
    "title": "1. Terminal",
    "section": "Viewing File Contents",
    "text": "Viewing File Contents\nTo see the contents of a file, you can use the cat (concatenate) command:\ncat /etc/hostname\nThis displays the contents of the file directly in the terminal.\nFor larger files, you might want to use a pager to view them one screen at a time. The less command is perfect for this:\nless /etc/profile\nInside less, you can use arrow keys to scroll, Page Up/Page Down for larger jumps, and q to quit.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#options-and-arguments",
    "href": "01_terminal.html#options-and-arguments",
    "title": "1. Terminal",
    "section": "Options and Arguments",
    "text": "Options and Arguments\nMost commands accept options (also called flags or switches) and arguments. The general format is:\ncommand -options arguments\nOptions typically start with a hyphen (-) or double hyphen (--). Let’s see this in action:\nls -l\nThe -l option shows a “long” listing with more details. Try:\nls -t\nThe -t option sorts files by modification time. You can combine multiple options:\nls -lt\nThis combines -l and -t to show details sorted by time.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#important-rules",
    "href": "01_terminal.html#important-rules",
    "title": "1. Terminal",
    "section": "Important Rules",
    "text": "Important Rules\n\n\n\n\n\n\nTry to avoid any spaces in your directory and file names. Shell interprets space as separator between options or arguments. Space in names will most likely break programs, producing errors.\nYou can use spaces by including names in parentheses or quotes, but that’s an unnecessary complication.\n\n\n\n\n\n\n\n\n\nCommands are case sensitive. ls is not the same as LS, Ls, or lS. Try it yourself!",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#directories",
    "href": "01_terminal.html#directories",
    "title": "1. Terminal",
    "section": "Directories",
    "text": "Directories\nLets create our first object using the terminal. While in your home directory ~, type:\nmkdir oist\nCheck with ls what happened. mkdir stands for make directory.\nLooks nice! Let’s go inside.\ncd oist\nAnd, check check it out.\nls\nKind of boring here. There is nothing inside. Let’s make some more directories inside.\nmkdir lab1 lab2 lab3 lab4 lab5\nThere’s something a little different about that command. So far we’ve only seen commands that work on their own (cd, pwd) or that have a single item afterwards (cd -, cd ~/Desktop/). But this time we’ve added three things after the mkdir command. Those things are referred to as parameters or arguments, and different commands can accept different numbers of arguments. The mkdir command expects at least one argument, whereas the cd command can work with zero or one, but no more. See what happens when you try to pass the wrong number of parameters to a command:\nmkdir\ncd /etc/ ~/Desktop/\nNotice that mkdir created all the folders in one directory. It didn’t create lab3/ inside lab2/ inside lab1/, or any other nested structure. But sometimes it’s handy to be able to do exactly that, and mkdir does have a way:\nmkdir -p lab4/levelE/48\nls\nYou can try to run without -p and see which error message you get.\nmkdir lab5/levelD/23\nI find this behaviour annoying. THe same goes for creating files in non-exicsting subdirectories but I am sure there is a good rason behind such restriction.\ncd lab4\nls\ncd levelE\nls\ncd ../..\nThe “-p” that we used is called an option or a switch (in this case it means “create the parent directories, too”). Options are used to modify the way in which a command operates, allowing a single command to behave in a variety of different ways. Unfortunately, due to quirks of history and human nature, options can take different forms in different commands. You’ll often see them as single characters preceded by a hyphen (as in this case), or as longer words preceded by two hyphens. The single character form allows for multiple options to be combined, though not all commands will accept that. And to confuse matters further, some commands don’t clearly identify their options at all, whether or not something is an option is dictated purely by the order of the arguments! You don’t need to worry about all the possibilities, just know that options exist and they can take several different forms. For example the following all mean exactly the same thing:\n# These commands are equivalent\nmkdir --parents --verbose lab5/levelDE\nmkdir -p --verbose lab5/levelDE\nmkdir -p -v lab5/levelDE\nmkdir -pv lab5/levelDE",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#files",
    "href": "01_terminal.html#files",
    "title": "1. Terminal",
    "section": "Files",
    "text": "Files\nMany labs, right? Can we keep a log of them? ls just printed them but can we store this command output in a file? That’s where redirecton comes into play.\nSuppose we wanted to capture the output of that command as a text file that we can look at or manipulate further. All we need to do is to add the greater-than character (“&gt;”) to the end of our command line, followed by the name of the file to write to:\nls &gt; lab.log\nThis time there’s nothing printed to the screen, because the output is being redirected to our file instead. If you just run ls on its own you should see that the lab.log file has been created. We can use the cat command to look at its content:\ncat lab.log\nOkay, so it’s not exactly what was displayed on the screen previously, but it contains all the same data, and it’s in a more useful format for further processing.\nLet’s look at another command, echo:\necho \"VISION, CHALLENGES, INNOVATION\"\nYes, echo just prints its arguments back out again (hence the name). But combine it with a redirect, and you’ve got a way to easily create small files. Let’s redirect these words into a file that will represent the Prof. Sydney Brenner statue located at the Center Court.\n\n\n\nDr. Brenner’s statue presented by Okinawa Prefecture and the Council for Promotion of OIST https://www.oist.jp/image/dr-sydney-brenners-statue\n\n\necho \"VISION, CHALLENGES, INNOVATION\" &gt; sydney_brenner.statue\ncat sydney_brenner.statue\n\n\n\n\n\n\nImportantFile extension\n\n\n\nLinux-type systems do not care about file extensions. Files can have no extensions at all and be absolutely fine. Try redirecting the words output to file named sydney_brenner and see if you can inspect it.\n\n\nWe have one statue but why stop here? It is not improbable that Prof. Svante Pääbo will get his statute at OIST in the future. For his statue engraving we will choose something more personal.\necho \"I really wanted to discover mummies, like Indiana Jones.\" &gt; svante_paabo.statue\ncat `svante_paabo.statue`\nHowever, cat is more than just a file viewer - its name comes from ‘concatenate’, meaning “to link together”. If you pass more than one filename to cat it will output each of them, one after the other, as a single block of text:\ncat sydney_brenner.statue svante_paabo.statue\nWhere you want to pass multiple file names to a single command, there are some useful shortcuts that can save you a lot of typing if the files have similar names. A question mark (“?”) can be used to indicate “any single character” within the file name. An asterisk (“*”) can be used to indicate “zero or more characters”. These are sometimes referred to as “wildcard” characters. A couple of examples might help, the following commands all do the same thing:\ncat sydney_brenner.statue svante_paabo.statue\ncat *.statue\nThat is where file extension .statue that we came up with is useful. We can match all statue files no matter how many there are. lab.log has been omitted. This simple syntax makes selective manipulation of files an easy task.\n\n\n\n\n\n\nAs you might have guessed, this capability also means that you need to escape file names with “?” or “*” characters in them, too. It’s usually better to avoid any punctuation in file names if you want to manipulate them from the command line.\n\n\n\nWe have not used ? character above. A somewhat artificial example with our current setup would be to list only the lab directories and their subdirectories:\nls lab?\nThus we only look at what is inside the directories that start with “lab”.\nGoing back to the statues. Let’s join all our files together into a single new file, then view it:\ncat *.statue &gt; nobel_motivation.txt\ncat nobel_motivation.txt\nWhat do you think will happen if we run those two commands a second time? Will the computer complain, because the file already exists? Will it append the text to the file, so it contains two copies? Or will it replace it entirely? Give it a try to see what happens, but to avoid typing the commands again you can use the Up Arrow and Down Arrow keys to move back and forth through the history of commands you’ve used. Press the Up Arrow a couple of times to get to the first cat and press Enter to run it, then do the same again to get to the second.\nAs you can see, the file looks the same. That’s not because it’s been left untouched, but because the shell clears out all the content of the file before it writes the output of your cat command into it. Because of this, you should be extra careful when using redirection to make sure that you don’t accidentally overwrite a file you need. If you do want to append to, rather than replace, the content of the files, double up on the greater-than character “&gt;&gt;”:\ncat *.statue &gt;&gt; nobel_motivation.txt\necho \"I want my statue too!\" &gt;&gt; nobel_motivation.txt\ncat nobel_motivation.txt\nRepeat the first cat and the echo a few more times, using the Up Arrow for convenience until your text document is so large that it won’t all fit in the terminal at once when you use cat to display it. In order to see the whole file we now need to use a different program, called a pager (because it displays your file one “page” at a time). The standard pager of old was called more, because it puts a line of text at the bottom of each page that says “–More–” to indicate that you haven’t read everything yet. These days there’s a far better pager that you should use instead: because it replaces more, the programmers decided to call it less.\nless nobel_motivation.txt\nWhen viewing a file through less you can use the Up Arrow, Down Arrow, Page Up, Page Down, Home and End keys to move through your file. Give them a try to see the difference between them. When you’ve finished viewing your file, press q to quit less and return to the command line.\n\n\n\n\n\n\nTipGood naming practice\n\n\n\nWhen you consider both case sensitivity and escaping, a good rule of thumb is to keep your file names all lower case, with only letters, numbers, underscores and hyphens. For files there’s usually also a dot and a few characters on the end to indicate the type of file it is (referred to as the “file extension”). This guideline may seem restrictive, but if you end up using the command line with any frequency you’ll be glad you stuck to this pattern.\n\n\nIf we want to move Sydney to show him the latest lab, Lab 5, how do we do that? Also, is the file we created created empty? How can we check that? ls will not work. We will see how files can be manipulated in the next section.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#renaming-files",
    "href": "01_terminal.html#renaming-files",
    "title": "1. Terminal",
    "section": "Renaming Files",
    "text": "Renaming Files\nThe mv command doesn’t just move files between directories—it’s also used to rename them. When you move a file to the same directory but give it a new name, you’re effectively renaming it.\nFor example, let’s rename one of our statue files:\nmv sydney_brenner.statue brenner_sydney.statue\ncat brenner_sydney.statue\nThe file has been renamed, not moved to a different location.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#copying-files",
    "href": "01_terminal.html#copying-files",
    "title": "1. Terminal",
    "section": "Copying Files",
    "text": "Copying Files\nSometimes you want to create a duplicate of a file. This is where the cp (copy) command comes in:\ncp brenner_sydney.statue sydney_brenner.statue\nls *.statue\nYou now have two files: the original and the last-name-first copy. The cp command can also work with directories, but you need to use an option to do so. To copy an entire directory and all its contents, use the -r option (which stands for “recursive”):\ncp -r lab4 lab0\nls\nThis creates a complete copy of lab4/ and all the files inside it, called lab6/.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#deleting-files-and-directories",
    "href": "01_terminal.html#deleting-files-and-directories",
    "title": "1. Terminal",
    "section": "Deleting Files and Directories",
    "text": "Deleting Files and Directories\nTo remove files, use the rm (remove) command. Be careful with this—once deleted, files are generally gone for good!\nrm brenner_sydney.statue\nls *.statue\nTo be honest, there is only one Lab0. To remove a directory, add the -r option:\nrm -r lab0\nls\n\n\n\n\n\n\nCautionWarning: rm is permanent\n\n\n\nUnlike moving files to a trash or recycle bin on a graphical interface, rm permanently deletes files. There is no undo! Always double-check your command before pressing Enter.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#downloading-files-from-the-web",
    "href": "01_terminal.html#downloading-files-from-the-web",
    "title": "1. Terminal",
    "section": "Downloading Files from the Web",
    "text": "Downloading Files from the Web\nAnother powerful command you encountered during the setup process is curl (Client URL). It’s used to transfer data from or to a server, often for downloading files or scripts from the internet:\ncurl -fsSL https://pixi.sh/install.sh | sh\nThis command downloads the Pixi installation script and pipes it directly to sh (the shell) for execution. Let’s break down the options:\n\n-f - Fail silently on server errors\n-s - Silent mode (don’t show progress)\n-S - Show errors even in silent mode\n-L - Follow redirects if the URL has moved\n\nYou can also use curl to download files and save them:\ncurl -O https://example.com/file.txt\nThe -O option saves the file with its original name.\n\n\n\n\n\n\nBe cautious when piping downloaded scripts directly to a shell interpreter (| sh or | bash). Only do this with scripts from trusted sources, as they will execute with your user privileges. During setup, you used this method with official installation scripts from Pixi and Starship.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "01_terminal.html#reloading-configuration-files",
    "href": "01_terminal.html#reloading-configuration-files",
    "title": "1. Terminal",
    "section": "Reloading Configuration Files",
    "text": "Reloading Configuration Files\nWhen you modify configuration files like .bashrc or .zshrc, the changes won’t take effect until you start a new terminal session. However, you can reload the configuration without closing your terminal using the source command:\nsource ~/.bashrc\nOr for Zsh users:\nsource ~/.zshrc\nThis reads and executes the commands from the specified file in your current shell session. You used this command during setup to activate Pixi after installation.\n\n\n\n\n\n\nYou can view the contents of your configuration files using cat ~/.bashrc or less ~/.bashrc to see what customizations you’ve made.\n\n\n\nAs you progress through more advanced topics, you’ll encounter many more hidden files and directories. Configuration files, cache directories, and version control metadata (like .git/) all use the dot-prefix convention. This naming strategy keeps your file system organized and separates system/application configuration from your regular working files. In future lessons, we’ll explore how these hidden files and directories make it very convenient to manage complex configurations without cluttering your workspace.",
    "crumbs": [
      "1. Terminal"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Good Enough Computing in Science (GECS)Mini Course at OIST",
    "section": "",
    "text": "flowchart LR\nA[Experiment] --&gt; B[Data]\n\n%% Parallel paths (layout only)\nsubgraph Reproducible\ndirection TB\nC(**GECS**)\nend\n\nsubgraph Irreproducible\ndirection TB\nE[Ad-hoc]\nend\n\nB --&gt; C\nB --&gt; E\n\nC --&gt; G[Results]\nE --&gt; G\n\n%% Emphasize GECS edges\nlinkStyle 1 stroke-width:4px\nlinkStyle 3 stroke-width:4px\n\n%% Node styles\nclassDef gecs fill:#cfe9e5,stroke:transparent,color:#000\nclassDef adhoc fill:#eeeeee,stroke:transparent,color:#000\nclassDef neutral fill:#f7f7f7,stroke:transparent,color:#000\nclassDef results fill:#e6dff1,stroke:transparent,color:#000\n\n%% Apply styles\nclass C gecs\nclass E adhoc\nclass A,B neutral\nclass G results\n\n%% Make subgraphs invisible\nstyle Reproducible fill:transparent,stroke-width:0px\nstyle Irreproducible fill:transparent,stroke-width:0px",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#drop-in",
    "href": "index.html#drop-in",
    "title": "Good Enough Computing in Science (GECS)Mini Course at OIST",
    "section": "Drop-in",
    "text": "Drop-in\nAfter every session there will be a drop-in the following week. You can come with questions or problems regarding the course.\nTime: 12:00-13:00 (Wednesdays)\nLocation: C102 (The Cafe Private Room)\nDates: Jan 21, Jan 28, Feb 4 for the Part 1; Mar 11, Mar 25, and Apr 1 for the Part 2.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#setting-up",
    "href": "index.html#setting-up",
    "title": "Good Enough Computing in Science (GECS)Mini Course at OIST",
    "section": "Setting Up",
    "text": "Setting Up\nIf you need help with configuring your computer for the course, a session will be held on January 14 Wednesday at the Cafe Private Room during the lunchtime, 12:00-13:00. See Setting up section.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#acknowledgements",
    "href": "index.html#acknowledgements",
    "title": "Good Enough Computing in Science (GECS)Mini Course at OIST",
    "section": "Acknowledgements",
    "text": "Acknowledgements\nArthur Turrell, Greg Wilson and The Carpentries, Justin Bois, Richard McElreath, and the MulQuaBio collective.",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Good Enough Computing in Science (GECS)Mini Course at OIST",
    "section": "References",
    "text": "References\n\n“Good artists copy, great artists steal.”\n— Pablo Picasso\n\n\nCoding for Economists by Arthur Turrell\nPython for Data Science by Arthur Turrell\nbootcamp by Justin Bois\nResearch Software Engineering with Python by The Carpentries\nThe Multilingual Quantitative Biologist by the MulQuaBio collective",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "00_setting_up.html",
    "href": "00_setting_up.html",
    "title": "0. Setting Up",
    "section": "",
    "text": "This section will equip your computer with all necessary tools for this course. The motivation behind each tool will be explained in the later sessions. For now, just follow the instructions and prepare to awe (and, at times, get frustrated) with power of computing.\nAlthough the course advertises itself as programming language agnostic, Python will be used to provide ‘meat’ for coding examples. See a Justin Bois’s note on “superiority” of one programming language over another below.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting_up.html#wsl-windows-users-only",
    "href": "00_setting_up.html#wsl-windows-users-only",
    "title": "0. Setting Up",
    "section": "WSL (Windows users only)",
    "text": "WSL (Windows users only)\nBeing a popular operating system doesn’t make Windows easy to use for software development. Windows Subsystem for Linux (WSL) circumvents this problem by creating a separate environment on your computer to run Linux, a free UNIX-like OS. We will install Linux with a particular flavour called Ubuntu. Right now, we will not go into details. All you need to know is that by the end of this installation you will be free to use a vast majority of scientific software available on the web.\n\nInstallation\nThere are two ways to install WSL with Ubuntu: graphical and terminal. The graphical method uses the Microsoft Store and should be straightforward. The terminal method uses PowerShell and is less user-friendly but more robust to errors. Choose whichever suits you best.\n\n\n\n\n\n\nNoteTroubleshooting WSL\n\n\n\n\n\nIf you’re experiencing some troubles with installation, it is worth:\n\nUpdating your Windows version. Open Windows Settings, go to ‘Updates and Security’ and hit ‘Check for Updates’.\nEnable WSL on your Windows manually.\n\nClick on the Start Menu and search for “Turn Windows features on or off”.\nOpen the result. A new window will appear with a list of Windows features.\nScroll down and check the following two boxes:\n\n‘Windows Subsystem for Linux’ ✅\n‘Virtual Machine Platform’ ✅\n\nClick OK. Windows will apply the changes and may ask you to restart your computer.\nAfter restarting, WSL will be enabled on your system.\n\n\n\n\n\n\nOpen the Start Menu, and search for “PowerShell”.\nRight-click and choose “Run as administrator”.\nEnter the following command to install WSL and hit Enter:\nwsl --install\n\n\n\n\n\n\n\n\nYou need to restart your computer after installing WSL.\n\n\n\n\nOnce restarted, open PowerShell again in the administartive mode and type:\nwsl --install\nBy default, Ubuntu will be installed as the main Linux distribution.\n\n\n\nCreating a Default UNIX User Account\nNow, that you have Ubuntu installed, you need to create an account in order to start using it. Generally it is called a “UNIX User Account” but a “Ubuntu account” would do as well.\n\n\n\n\n\n\nBefore you set a username on your computer, sign up for a GitHub account (see Section 4.1) and check if that username is available. This unity in names will make it easier for you to orient your files and folder,as well establish a virtual nickname that you can use consistently in the future projects.\n\n\n\n\n\n\n\n\n\n\nTipUsername and password suggestions\n\n\n\n\n\nFor a username: - Use only lower-case letters and numbers. - Start with a letter. - Be short and descriptive.\nIf your name is John Derek Smith you can try: jsmith, jdsmith, or johnsmith. Any other imaginary name is permissible as long as it meets the criteria above. D&D, MTG, LoL, and WoW nicknames, if that’s is publically appropriate.\nFor a password, you can set the same one you have for your OIST account to make it easier to remember. It will be used for login and authentication but, more importantly, commands like sudo that grant administrative priviledges. If not sure what makes a strong password consult XKCD.\n\n\n\n\nLaunch Ubuntu terminal.\n\n\n\nYou will be prompted to enter a username.\n\n\nEnter your chosen username and hit Enter. If you make a mistake in typing your username, you can close the window and open it again. In this example, tunkert is the username.\n\n\n\n\n\n\nIf you closed the terminal window or made a mistake while typying your username or password do not worry. Ubuntu is already installed on your computer and you can open it from the Command Promt application.\n\n\n\n\n\nChoose a password. You will not see it as you type due to default UNIX security reasons. If not sure what you entered is correct, hold Backspace for a couple of seconds or hit Ctrl+U. That will erase everything you have written. After making sure you have entered the correct password, hit Enter. If unsure, write the password down.\n\n\n\nRe-type the chosen password and hit Enter.\n\n\n\nOnce both username and password are entered, you will see a welcome message from Ubuntu.\n\n\n\n\n\n\n\n\nThe typing line takes the new form of tunkert@LAPTOP-JU9CGB60:~$. Can you guess what the name after @ means? We will talk about what each symbol means in the terminal section.\n\n\n\n\nTo ensure that Ubuntu is up-to-date, type the following and press Enter:\n\nsudo apt update && sudo apt upgrade -y\n\n\n\n\n\n\nWe will understand the logic behind this command later in the next section as well.\n\n\n\n\n\nYou will be prompted to enter the password (Do you remember?). Enter the password—you will not see it—and press Enter.\n\n\n\nThe update will begin. In the end, you will have an empty typing line with the latest Ubuntu.\n\n\n\n\n\n\n\n\nTipDefault Command Prompt settings\n\n\n\nI suggest you make Ubuntu your Default profile. Command Promt &gt; Settings &gt; Start-up &gt; Default profile, choose Ubuntu and press Save.\n\n\nYou are now set and ready to install all the wonderful programming tools that have been developed over the past 50 or so years by the developer’s community. As you might guess, there are hundreds of thousands of programs out there, and ideally, we would like to keep track of what we install. That will be our next installation.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting_up.html#visual-studio-code",
    "href": "00_setting_up.html#visual-studio-code",
    "title": "0. Setting Up",
    "section": "Visual Studio Code",
    "text": "Visual Studio Code\nVisual Studio Code, aka VS Code, has the following useful features:\n\na way to run your code interactively (line-by-line) or all at once\na way to debug (look for errors) in your code\na quick way to access helpful information about commonly used software packages\nautomatic code formatting, so that your code follows best practice guidelines\nauto-completion of your code when you hit TAB\nautomatic code checking for basic errors\ncoloring your brackets in pairs so you can keep track of the logical order of execution of your code!\n\n\n\nInstallation\nInstall VS Code from the official website (it will determine which version of the installer to use) or download installer manually here.\n\n\n\n\n\n\n\nNoteVS Code WSL extension\n\n\n\n\n\nWindows users will be promted to install the VS Code WSL extension. Agree and see Section 2.1.2.1.\n\n\n\n\n\nExtensions\nThe biggest power of VS Code lies in its extensions. They are ubiquitous allowing you to boost your IDE simply by installing what others have solved for you. You can browse them by clicking on the four cube icon on the side bar or by pressing Cmd/Ctrl+Shift+X.\n\nThere are certain basic extensions that almost every VS Code user will have installed but it can be cumbersome to manually select all those one by one. That’s how VS Code Profiles have been created.\n\nWSL Extenison (Windows users only)\nWindows user will need one more step before they can start using VS Code at its full potential. Right now, you open VS Code and all files and computation is done in Windows environment. We want VS Code to use Ubuntu that lives in WSL. Using the Visual Studio Code WSL extension VS Code will integrate Ubuntu into its environment.\nOnce the extension is installed you need to open VS Code with Ubuntu as the main environment. To do that, locate a button in the left-bottom corner of the VS Code window consisting of two stacked arrow symbols ‘&gt;’ and ‘&lt;’. Click on it.\n\nAfter clicking on this button, a promt line will appear on the top of the window. Select WSL: New WSL Window and press Enter.\n\nA new window will open. This time, notice that the corner button has changed. Now, we are running on Ubuntu.\n\nWindows users will use this environment for the course.\n\n\n\nProfiles\n\nProfiles can be used to customize VS Code for students to ease the use in a classroom setting. Profiles allow educators to quickly share a customized VS Code setup with students.\nVS Code manual\n\n\nYou can access the Profiles editor in either of the following ways: - From the Code &gt; Settings &gt; Profiles menu item\n\nFrom the Manage gear button in the bottom of the Activity Bar.\n\n\nYou will see that the Default profile is in use. We will import the GECS profile for this course. The profile file is stored on GitHub (one of its nice features). That code is shown below.\n\nHowever, you don’t need to copy it, only need the link.\nhttps://gist.github.com/igorsdub/04f6a1191dde8e09091a1099fe87d5be\nImport the GECS profile from the Profiles editor by selecting the Import Profile… button in the dropdown actions of the New Profile button.\n\nWhen you select Import Profile…, you are prompted for the URL of a GitHub gist or the file location of a profile via an Import Profile dialog. Paste the link above and click Create button below.\n\n\n\nAccept any installations or suggestions offered by extensions. Now, you are ready to go!",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting_up.html#pixi",
    "href": "00_setting_up.html#pixi",
    "title": "0. Setting Up",
    "section": "Pixi",
    "text": "Pixi\nPixi is the latest package manager and unlike its competition (e.g. Conda, Mamba, uv) supports many programming languages besides Python and is gaining momentum among software developers and scientist.\nHere we will have to use a terminal since Pixi can not be installed using a visual application, say by downloading an .exe file for Windows or .dmg for macOS.\n\n\n\n\n\n\nThat’s the reason we went to such lengths to install Ubuntu on Windows. Now, you are able to access a much larger range of applications which are inaccessible to graphical user interface (GUI) users.\n\n\n\nWe will use the VS Code’s terminal to do the installation. To open the terminal select View &gt; Terminal from the menu bar, or by pressing the Ctrl/Cmd+` keyboard shortcut. A terminal window will open at the bottom.\n\nTo install Pixi run the following command in your terminal:\ncurl -fsSL https://pixi.sh/install.sh | sh\nTo verify that Pixi got installed successfully restart the terminal. There are two ways to do so. Easy way is to kill it and open a new terminal window. Another way is to type the following for Ubuntu users:\nsource ~/.bashrc\nmacOS user need to type:\nsource ~/.zshrc\nOK, now that the terminal is reset, type:\nwhich pixi\nYou will see something like /Users/username/.pixi/bin/pixi printed, where username is your chosen username.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting_up.html#sec-github",
    "href": "00_setting_up.html#sec-github",
    "title": "0. Setting Up",
    "section": "GitHub",
    "text": "GitHub\nGitHub is a widely used platform to store, manage, share, and collaborate with others on software projects. An account is free and you can upgrade to Pro for free as a student (see the tip below). Sign up here.\n\n\n\n\n\n\nTipGitHub Education\n\n\n\n\n\nAs a student, you can get a free GitHub Pro account as part of GitHub Education alongside other perks. Once you have a basic account, follow this link.\nYou can use a photo of your student ID card (both-sides) or other eligible documents listed on here.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting_up.html#starship",
    "href": "00_setting_up.html#starship",
    "title": "0. Setting Up",
    "section": "Starship",
    "text": "Starship\nStarship is by far the most widely used shell prompt. It is a customizable prompt that controls how your terminal looks when you type a command. It is pretty and versatile.\n\nTo install Starship open VS Code terminal by selecting View &gt; Terminal from the menu bar, or by pressing the Ctrl/Cmd+` keyboard shortcut. A terminal window will open at the bottom. Then type:\ncurl -sS https://starship.rs/install.sh | sh\nNext, you will need to tell the terminal to start Starship every time you open a new terminal. This is similar to how Windows or macOS asks you if you want to run a program every time you start your computer.\nWindows/Ubuntu users must execute in their terminal the following:\necho 'eval \"$(starship init bash)\"' &gt;&gt; ~/.bashrc\nmacOS users have a very similar command:\necho 'eval \"$(starship init zsh)\"' &gt;&gt; ~/.zshrc\nAfter you restart the terminal, close it and open a new one, you should see the change in how it looks like. You can explore all the different looks you can access with Starship here.",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting_up.html#setup-and-installation-guides",
    "href": "00_setting_up.html#setup-and-installation-guides",
    "title": "0. Setting Up",
    "section": "Setup and Installation Guides",
    "text": "Setup and Installation Guides\n\nHow to Install Ubuntu on Windows (Step-by-Step Guide for Beginners) by Subha Mondal\nWindows Subsystem for Linux Documentation",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "00_setting_up.html#tools-and-platforms",
    "href": "00_setting_up.html#tools-and-platforms",
    "title": "0. Setting Up",
    "section": "Tools and Platforms",
    "text": "Tools and Platforms\n\nVisual Studio Code\n\nVisual Studio Code Official Website\nVS Code WSL Extension Guide\nVS Code Remote WSL Documentation\nVS Code Terminal Getting Started\n\n\n\nPackage Managers\n\nPixi Official Documentation\nPixi Installation Guide\n\n\n\nShell Customization\n\nStarship Shell Prompt\nStarship Presets",
    "crumbs": [
      "0. Setting Up"
    ]
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "flowchart LR\n  A[Data] --&gt; B[Clean] --&gt; C[Analysis] --&gt; D[Results] --&gt; E[Figures] --&gt; F[Paper]\n\n  subgraph GECS[GECS]\n    direction LR\n    B\n    C\n    D\n    E\n  end\n\n  style GECS fill:#eef,stroke:#66f,stroke-width:2px\n\n\n\n\n\n\n\n\n\n\n\n\nflowchart LR\n  subgraph GECS\n    direction TB\n    B1 --&gt; B2 --&gt; B3 --&gt; B1\n  end\n  A(Raw Data) --&gt; GECS --&gt; Z(Paper)"
  }
]